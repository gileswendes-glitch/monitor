<!DOCTYPE html>
<html lang="en">
<head>
    <title>KHS IT Monitor</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <style>
        /* === CORE LAYOUT === */
        body { margin: 0; background: #121212; display: flex; font-family: 'Inter', sans-serif; overflow: hidden; height: 100vh; color: #e0e0e0; }
        .sidebar { width: 320px; background: #1e1e1e; display: flex; flex-direction: column; padding: 15px; box-shadow: 0 0 30px rgba(0,0,0,0.5); z-index: 2000; height: 100vh; box-sizing: border-box; }
        #sidebar-left { border-right: 1px solid #333; }
        #sidebar-right { border-left: 1px solid #333; }
        #main-content { flex-grow: 1; display: flex; flex-direction: column; background: #000; }

        /* === CARDS === */
        .card { background: #252525; padding: 15px; border-radius: 12px; margin-bottom: 20px; border: 1px solid #333; position: relative; box-shadow: 0 4px 6px rgba(0,0,0,0.1); display: flex; flex-direction: column; flex-shrink: 0; transition: all 0.3s ease; }
        .card-cloud { border-top: 3px solid #28a745; } 
        .card-local { border-top: 3px solid #ffc107; } 
        .card-firewall { border-top: 3px solid #fd7e14; } 
        .card-hardware { border-top: 3px solid #e83e8c; } 
        .card-nvr { border-top: 3px solid #6f42c1; } 
        .card-esxi { border-top: 3px solid #607d8b; } 
        .card-switch { border-top: 3px solid #17a2b8; } 
        .card-printer { border-top: 3px solid #0d6efd; } 
        .card-telephone { border-top: 3px solid #00bcd4; } 
        .card-wap { border-top: 3px solid #3f51b5; } 
        .card-access { border-top: 3px solid #9c27b0; } 
        .card-cctv { border-top: 3px solid #f44336; }
        
        .card-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; cursor: pointer; }
        .card h2 { margin: 0; font-size: 13px; color: #888; text-transform: uppercase; letter-spacing: 1.5px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
        .count-badge { font-weight: 400; color: #666; font-size: 12px; }
        
        /* === LIST WINDOWS & SCROLL === */
        .list-window { padding-right: 5px; overflow-y: hidden; position: relative; transition: max-height 0.4s ease, opacity 0.4s ease; opacity: 1; max-height: 280px; }
        .list-window.minimized { max-height: 0 !important; margin: 0; padding: 0; opacity: 0; pointer-events: none; }
        .list-window.expanded { max-height: none; overflow-y: visible; }
        .gone { display: none !important; }

        /* === SERVICE ITEMS === */
        .service-item { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #333; font-size: 13px; color: #ccc; cursor: pointer; transition: background 0.2s; }
        .service-item:hover { background: rgba(255,255,255,0.05); }
        .service-sub { font-size: 11px; color: #777; margin-top: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 200px; }
        
        /* === FIREWALL === */
        .fw-row { display: flex; justify-content: space-between; align-items: center; padding: 6px 0; border-bottom: 1px solid #333; font-size: 13px; }
        .fw-row:last-child { border-bottom: none; }
        .fw-label { color: #888; }
        .fw-val { font-weight: 600; color: #fff; }

        /* === STATUS DOTS === */
        .status-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }
        .online { background: #00d26a; box-shadow: 0 0 8px rgba(0, 210, 106, 0.4); }
        .amber { background: #ffc107; box-shadow: 0 0 8px rgba(255, 193, 7, 0.6); animation: pulse-amber 2s infinite; }
        .offline { background: #f8312f; box-shadow: 0 0 10px rgba(248, 49, 47, 0.6); animation: flash-red 0.8s infinite alternate; }
        @keyframes pulse-amber { 0% { opacity: 1; } 50% { opacity: 0.6; } 100% { opacity: 1; } }
        @keyframes flash-red { from { opacity: 1; box-shadow: 0 0 10px rgba(248, 49, 47, 0.8); } to { opacity: 0.3; box-shadow: 0 0 2px rgba(248, 49, 47, 0.2); } }

        /* === STAT BARS & DRIVE BLOCKS === */
        .stat-container { margin-top: 6px; width: 100%; }
        .stat-row, .toner-row { display: flex; align-items: center; margin-bottom: 3px; }
        .stat-label { font-size: 10px; color: #888; width: 30px; }
        .toner-label { font-size: 9px; color: #888; width: 15px; font-weight:bold; }
        .stat-track { flex: 1; background: #333; height: 6px; border-radius: 3px; overflow: hidden; position: relative; }
        .stat-fill { height: 100%; width: 0%; transition: width 0.5s ease; border-radius: 3px; }
        
        .fill-cpu { background: #3498db; } 
        .fill-ram { background: #9b59b6; } 
        .fill-disk { background: #f1c40f; } 
        .fill-cyan { background: #00d2ff; }
        .fill-magenta { background: #ff00d4; }
        .fill-yellow { background: #ffea00; }
        .fill-black { background: #888; }

        /* Drive Block Style */
        .drive-block { display: inline-block; height: 100%; border-right: 2px solid #252525; box-sizing: border-box; }

        /* === TICKER ANIMATION === */
        .ticker-mask { flex-grow: 1; overflow-y: auto; position: relative; mask-image: linear-gradient(to bottom, black 90%, transparent 100%); z-index: 10; scrollbar-width: none; }
        .ticker-mask::-webkit-scrollbar { display: none; }
        .ticker-content { position: absolute; top: 0; left: 0; width: 100%; padding-bottom: 50px; will-change: transform; }

        /* === HEADERS & UTILS === */
        .page-header { background: rgba(30, 30, 30, 0.9); backdrop-filter: blur(10px); color: #fff; padding: 15px 30px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; z-index: 10; font-size: 20px; flex-shrink: 0; }
        .badge { font-size: 11px; font-weight: bold; padding: 5px 10px; border-radius: 4px; text-transform: uppercase; letter-spacing: 1px; margin-right: 15px; cursor: pointer; user-select: none; transition: all 0.2s; }
        .badge-local { background: rgba(0, 210, 106, 0.15); color: #00d26a; border: 1px solid #00d26a; }
        .badge-cloud { background: rgba(253, 126, 20, 0.15); color: #fd7e14; border: 1px solid #fd7e14; }
        .weather-box { display: flex; flex-direction: column; align-items: flex-end; font-size: 14px; color: #aaa; text-align: right; cursor: pointer; padding: 10px 14px; border-radius: 8px; transition: all 0.2s; user-select: none; }
        .weather-box:hover { background: rgba(255,255,255,0.06); color: #fff; }
        .weather-main { display: flex; align-items: center; gap: 10px; font-size: 22px; color: #fff; font-weight: 600; }
        .weather-box .clock-display { font-size: 26px; font-variant-numeric: tabular-nums; letter-spacing: 0.02em; }
        .weather-box .date-display { font-size: 15px; margin-top: 4px; color: #aaa; }
        .weather-box .weather-temp { font-size: 22px; }
        .weather-box.theme-retro { font-family: 'Courier New', monospace; }
        .weather-box.theme-retro .clock-display { font-size: 28px; color: #0f0; text-shadow: 0 0 10px #0f0; }
        .weather-box.theme-retro .date-display { color: #0a0; }
        .weather-box.theme-retro .weather-temp { color: #0f0; }
        .weather-box.theme-analogue { font-family: Georgia, serif; }
        .weather-box.theme-analogue .clock-display { font-size: 24px; font-weight: 300; letter-spacing: 0.08em; }
        .weather-box.theme-analogue .date-display { font-style: italic; font-size: 14px; }
        .weather-box.theme-cartoon { font-family: 'Comic Sans MS', 'Chalkboard', cursive; }
        .weather-box.theme-cartoon .clock-display { font-size: 28px; color: #ff6b9d; text-shadow: 2px 2px 0 #333; }
        .weather-box.theme-cartoon .date-display { color: #6b8cff; font-weight: bold; }
        .weather-box.theme-cartoon .weather-temp { color: #ffb86b; }
        .weather-box.theme-matrix { font-family: 'Courier New', monospace; }
        .weather-box.theme-matrix .clock-display { font-size: 28px; color: #0f0; text-shadow: 0 0 10px #0f0; }
        .weather-box.theme-matrix .date-display { color: #0a0; }
        .weather-box.theme-matrix .weather-temp { color: #0f0; }
        
        /* === MAP & CONTROLS === */
        #map-wrapper { flex-grow: 1; position: relative; width: 100%; height: 100%; min-height: 200px; overflow: hidden; }
        #map-wrapper.map-theme-default { background: #ffffff; }
        #map-wrapper.map-theme-retro { background: #0a120a; }
        #map-wrapper.map-theme-analogue { background: #1a1814; }
        #map-wrapper.map-theme-cartoon { background: #1e1a2e; }
        #map-bg { position: absolute; inset: 0; z-index: 0; pointer-events: none; }
        #map-wrapper.map-theme-default #map-bg { background: #ffffff; }
        #map-wrapper.map-theme-retro #map-bg { background: #0a120a; }
        #map-wrapper.map-theme-retro #map-bg::after { content: ''; position: absolute; inset: 0; background: linear-gradient(180deg, transparent 0%, rgba(0,40,0,0.06) 100%); }
        #map-wrapper.map-theme-analogue #map-bg { background: #1a1814; }
        #map-wrapper.map-theme-cartoon #map-bg { background: #1e1a2e; }
        #map-matrix-rain { display: none; position: absolute; inset: 0; z-index: 0; overflow: hidden; pointer-events: none; }
        #map-wrapper.map-theme-retro #map-matrix-rain { display: block; }
        #matrix-rain-canvas { display: block; width: 100%; height: 100%; }
        #map-wrapper .leaflet-container, #map-wrapper #map { background: transparent !important; }
        #map { height: 100%; width: 100%; position: relative; z-index: 1; background: transparent !important; min-height: 150px; }
        #map-overlay { position: absolute; inset: 0; z-index: 10000; pointer-events: none; }
        #map-overlay > * { pointer-events: auto; }
        #map-title { position: absolute; top: 20px; right: 20px; background: rgba(20, 20, 20, 0.85); color: #e0e0e0; padding: 8px 20px; border-radius: 6px; backdrop-filter: blur(5px); border: 1px solid #444; }
        #map-controls { position: absolute; bottom: 20px; right: 20px; display: flex; flex-direction: column; align-items: flex-end; gap: 12px; }
        .map-controls-labels { display: flex; align-items: center; gap: 8px; padding: 6px 12px; background: rgba(20, 20, 20, 0.9); border: 1px solid #444; border-radius: 8px; backdrop-filter: blur(8px); font-size: 12px; color: #aaa; }
        .map-controls-labels label { cursor: pointer; user-select: none; display: flex; align-items: center; gap: 6px; }
        .map-controls-labels input[type="checkbox"] { cursor: pointer; accent-color: #00d26a; width: 14px; height: 14px; }
        .map-nav-buttons { display: flex; align-items: center; gap: 4px; padding: 4px; background: rgba(20, 20, 20, 0.9); border: 1px solid #444; border-radius: 10px; backdrop-filter: blur(8px); box-shadow: 0 2px 12px rgba(0,0,0,0.3); }
        .map-nav-btn { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border: none; background: transparent; color: #e0e0e0; border-radius: 8px; cursor: pointer; font-size: 18px; transition: background 0.2s, color 0.2s, transform 0.15s; }
        .map-nav-btn:hover { background: rgba(0, 210, 106, 0.2); color: #00d26a; transform: scale(1.05); }
        .map-nav-btn:active { transform: scale(0.98); }
        .map-nav-btn.pause-btn { min-width: 44px; font-size: 16px; }
        .control-btn { background: rgba(20, 20, 20, 0.85); color: #e0e0e0; border: 1px solid #444; padding: 10px 15px; border-radius: 6px; cursor: pointer; font-size: 14px; backdrop-filter: blur(5px); }
        .header-controls { display: flex; align-items: center; gap: 10px; }
        .toggle-btn, .expand-btn { cursor: pointer; font-size: 16px; opacity: 1; transition: all 0.2s; padding: 5px 6px; border-radius: 6px; }
        .toggle-btn { background: rgba(0,210,106,0.2); border: 1px solid rgba(0,210,106,0.4); box-shadow: 0 0 8px rgba(0,210,106,0.15); }
        .toggle-btn:hover, .expand-btn:hover { opacity: 1; background: rgba(255,255,255,0.15); }
        .expand-btn { background: rgba(255,255,255,0.06); }
        .toggle-btn.hidden-active { opacity: 0.4; filter: grayscale(100%); background: rgba(255,255,255,0.05); border-color: transparent; box-shadow: none; }
        .expanded-active { color: #00d26a; opacity: 1; transform: scale(1.1); font-weight: bold; }
        .force-hide { display: none; }
        .big-stat { font-size: 48px; font-weight: 300; color: #fff; letter-spacing: -2px; line-height: 1; }
        .unit { font-size: 13px; color: #666; font-weight: 500; margin-top: 5px; display: block; }
        .version-footer { margin-top: auto; text-align: center; font-size: 11px; color: #444; padding-top: 20px; border-top: 1px solid #2a2a2a; }

        /* === MODALS (MAIN LIST & POP-OUT) === */
        /* Universal Overlay Class */
        .modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 5000; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); }
        .modal-overlay.active { display: flex; }
        #device-detail-modal { z-index: 5500; }
        
        /* Main List Modal */
        #modal-content { background: #1e1e1e; width: 85%; max-width: 1200px; height: 85vh; border-radius: 12px; border: 1px solid #333; display: flex; flex-direction: column; box-shadow: 0 20px 50px rgba(0,0,0,0.5); }
        .modal-header { padding: 20px; border-bottom: 1px solid #333; display: flex; justify-content: space-between; align-items: center; background: #252525; border-radius: 12px 12px 0 0; }
        .modal-header h2 { margin: 0; font-size: 24px; color: #fff; }
        .modal-close { cursor: pointer; font-size: 28px; color: #888; margin-left: 15px; } .modal-close:hover { color: #fff; }
        .modal-body { flex: 1; overflow-y: auto; padding: 20px; }
        #modal-search { background: #333; border: 1px solid #444; padding: 8px 12px; color: #fff; border-radius: 6px; font-size: 14px; width: 250px; outline: none; }
        
        /* Device Detail Pop-Out */
        #device-detail-box { background: #1e1e1e; width: 500px; max-height: 90vh; border-radius: 12px; border: 1px solid #444; display: flex; flex-direction: column; box-shadow: 0 25px 60px rgba(0,0,0,0.8); z-index: 6000; }
        .dd-header { padding: 20px; background: #252525; border-bottom: 1px solid #333; border-radius: 12px 12px 0 0; display:flex; justify-content:space-between; align-items:flex-start; }
        .dd-body { padding: 25px; overflow-y: auto; }
        .dd-row { display: flex; justify-content: space-between; margin-bottom: 12px; font-size: 14px; border-bottom: 1px solid #2a2a2a; padding-bottom: 8px; }
        .dd-label { color: #888; font-weight: 500; }
        .dd-value { color: #eee; font-family: monospace; text-align: right; font-weight: bold; }
        .dd-section { margin-top: 20px; margin-bottom: 10px; font-size: 12px; color: #00d26a; text-transform: uppercase; font-weight: bold; letter-spacing: 1px; border-bottom: 1px solid #333; padding-bottom: 5px; }

        .detail-table { width: 100%; border-collapse: collapse; color: #ccc; font-size: 14px; }
        .detail-table th { text-align: left; padding: 12px; border-bottom: 1px solid #444; color: #888; text-transform: uppercase; font-size: 12px; position: sticky; top: 0; background: #1e1e1e; cursor: pointer; }
        .detail-table td { padding: 12px; border-bottom: 1px solid #333; vertical-align: top; }
        .detail-table tr:hover { background: #2a2a2a; }
        .detail-sub { font-size: 11px; color: #999; display: block; margin-top: 3px; font-family: monospace; white-space: pre-wrap; }
        .raw-data-btn { font-size: 10px; color: #00d26a; border: 1px solid #00d26a; padding: 2px 5px; border-radius: 3px; cursor: pointer; margin-left: 10px; background: transparent; }
        .raw-view-box { display: none; background: #111; color: #0f0; padding: 10px; font-family: monospace; font-size: 11px; margin-top: 5px; border-radius: 4px; overflow-x: auto; white-space: pre; border: 1px solid #333; }
        .raw-view-box.active { display: block; }

        /* === MOBILE RESPONSIVE === */
        @media screen and (max-width: 900px) {
            body { flex-direction: column; overflow-y: auto; height: auto; min-height: 100vh; }
            .sidebar { width: 100%; height: auto; max-height: 25vh; border: none !important; padding: 10px; overflow-y: auto; }
            #sidebar-left { order: 1; border-bottom: 1px solid #333 !important; border-right: none !important; }
            #sidebar-right { order: 2; border-bottom: 1px solid #333 !important; border-left: none !important; }
            #main-content { order: 3; flex-grow: 0; height: 50vh; min-height: 50vh; }
            .page-header { padding: 10px 15px; font-size: 16px; }
            .page-header .weather-box { display: none; }
            #map-wrapper { height: calc(50vh - 60px); }
            .ticker-mask { mask-image: none; overflow-y: auto; }
            .ticker-content { position: relative; padding-bottom: 0; }
            .card { margin-bottom: 10px; padding: 10px; }
            .list-window { max-height: 150px; }
            .version-footer { display: none; }
            .fixed-zone { max-height: 40%; overflow-y: auto; }
            #modal-content { width: 95%; height: 90vh; }
            #device-detail-box { width: 95%; }
            #modal-search { width: 120px; }
            .modal-header { flex-wrap: wrap; gap: 10px; }
            .detail-table { font-size: 12px; }
            .detail-table th, .detail-table td { padding: 8px 4px; }
        }

        /* === MAP MARKER STYLES === */
        .device-marker-wrapper.leaflet-div-icon { background: transparent !important; border: none !important; }
        .device-marker { border-radius: 50%; border: 2px solid rgba(255,255,255,0.8); box-shadow: 0 2px 8px rgba(0,0,0,0.5); cursor: pointer; transition: transform 0.2s; }
        .device-marker:hover { transform: scale(1.3); z-index: 1000 !important; }
        .device-marker-emoji { line-height: 1; text-align: center; display: flex; align-items: center; justify-content: center; border-radius: 50%; border: 2px solid rgba(255,255,255,0.9); box-sizing: border-box; overflow: hidden; width: 100%; height: 100%; }
        .device-marker-emoji img.device-type-icon { flex-shrink: 0; }
        .device-marker-emoji:hover { transform: scale(1.4); }
        .device-marker-emoji.marker-online { animation: none; }
        .device-marker-emoji.marker-amber { animation: pulse-emoji-amber 2s infinite; }
        .device-marker-emoji.marker-offline { animation: flash-emoji-red 0.8s infinite alternate; }
        @keyframes pulse-emoji-amber { 0% { opacity: 1; filter: drop-shadow(0 0 8px #ffc107); } 50% { opacity: 0.7; filter: drop-shadow(0 0 4px #ffc107); } 100% { opacity: 1; filter: drop-shadow(0 0 8px #ffc107); } }
        @keyframes flash-emoji-red { from { opacity: 1; filter: drop-shadow(0 0 10px #f8312f); } to { opacity: 0.4; filter: drop-shadow(0 0 2px #f8312f); } }
        .marker-online { background: #00d26a; }
        .marker-amber { background: #ffc107; animation: pulse-amber 2s infinite; }
        .marker-offline { background: #f8312f; animation: flash-red 0.8s infinite alternate; }
		
		/* === CCTV PILLS (Streaming/Bandwidth Badges) === */
.cctv-pill {
    display: inline-block;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.75rem;
    margin-right: 5px;
    border: 1px solid #333;
}
        .pill-active { background: #1b3a24; color: #4cd964; border-color: #2d5a36; } /* Streaming */
.pill-idle   { background: #1e1e1e; color: #777; border-color: #333; }      /* Idle */
.pill-data   { background: #1b283a; color: #007aff; border-color: #2d3f5a; } /* Bandwidth */

        /* === HISTORY CARD === */
        .card-history { border-top: 3px solid #17a2b8; }
        .history-row { display: flex; justify-content: space-between; align-items: center; padding: 8px 0; border-bottom: 1px solid #333; font-size: 12px; }
        .history-row:last-child { border-bottom: none; }
        .history-period { color: #888; font-weight: 600; }
        .history-ok { color: #00d26a; }
        .history-issues { color: #ffc107; }
        .history-fails { color: #f8312f; }
        .history-ack { color: #888; font-size: 11px; }
        .history-row.clickable { cursor: pointer; }
        .history-row.clickable:hover { background: rgba(255,255,255,0.05); border-radius: 4px; }

        /* === MAP LABELS & GROUP HIGHLIGHT === */
        .device-map-label { background: #fff !important; border: 1px solid #333 !important; border-radius: 2px !important; padding: 1px 3px !important; font-size: 10px !important; line-height: 1.2 !important; color: #000 !important; pointer-events: none !important; box-shadow: 0 1px 3px rgba(0,0,0,0.3); font-family: Inter, sans-serif; display: inline-block; text-align: center; }
        .device-map-label span { color: #000 !important; background: transparent !important; }
        .device-map-label .device-map-label-name { max-width: 84px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; display: block; text-align: center; }
        .device-map-label .device-map-label-ip { font-size: 9px; color: #555; display: block; margin-top: 0; line-height: 1.15; max-width: 84px; overflow: hidden; text-overflow: ellipsis; text-align: center; }
        .device-map-label.group { white-space: nowrap; }
        .device-map-label.group span { font-weight: 600; }
        .leaflet-tooltip.fault-zone-label { background: rgba(20, 20, 20, 0.9); border: 1px solid #444; border-radius: 6px; padding: 4px 10px; font-size: 11px; }

        /* === MAP MARKER TOOLTIP (mouseover name + IP) === */
        .device-marker-tooltip { background: rgba(20, 20, 20, 0.95) !important; border: 1px solid #444 !important; border-radius: 6px !important; padding: 6px 10px !important; font-size: 12px !important; color: #e0e0e0 !important; white-space: nowrap; }
        .device-marker-tooltip .device-marker-tooltip-content { white-space: normal; max-width: 240px; }
        .device-marker-tooltip .device-tt-name { font-weight: 600; color: #fff; }
        .device-marker-tooltip .device-tt-ip { font-family: monospace; font-size: 11px; color: #aaa; margin-top: 2px; }
        .device-map-ghost { background: transparent !important; border: none !important; pointer-events: auto !important; }

        /* === RADAR PING (locate highlight) === */
        .radar-ping-wrap { position: relative; width: 80px; height: 80px; margin: -40px 0 0 -40px; pointer-events: none; }
        .radar-ping-ring { position: absolute; left: 50%; top: 50%; width: 24px; height: 24px; margin: -12px 0 0 -12px; border: 2px solid #4a9eff; border-radius: 50%; animation: radar-ping 1.4s ease-out infinite; }
        .radar-ping-ring:nth-child(2) { animation-delay: 0.35s; }
        .radar-ping-ring:nth-child(3) { animation-delay: 0.7s; }
        @keyframes radar-ping { 0% { transform: scale(0.5); opacity: 1; } 100% { transform: scale(3.2); opacity: 0; } }

        /* === MAP: ACKNOWLEDGED / PROBLEM ZONE === */
        .marker-acknowledged { border: 2px dashed #888 !important; opacity: 0.9; }
        .problem-zone-circle { fill: none; stroke: #f8312f; stroke-width: 2; stroke-opacity: 0.6; stroke-dasharray: 4 4; }
        .fault-zone-label { font-size: 11px; font-weight: 600; color: #fff !important; text-shadow: 0 1px 3px #000, 0 0 8px rgba(0,0,0,0.8) !important; white-space: nowrap; pointer-events: none; background: rgba(0,0,0,0.6) !important; border: 1px solid #f8312f !important; padding: 4px 8px !important; border-radius: 4px !important; }
    </style>
</head>
<body>

<div id="device-detail-modal" class="modal-overlay" style="display:none;">
    <div id="device-detail-box">
        <div class="dd-header">
            <div>
                <h2 id="dd-name" style="color:#fff; margin:0; font-size:20px;">Device Name</h2>
                <span id="dd-sub" style="font-size:12px; color:#888;">TYPE ‚Ä¢ IP</span>
            </div>
            <span class="modal-close" onclick="document.getElementById('device-detail-modal').classList.remove('active'); setTimeout(()=>document.getElementById('device-detail-modal').style.display='none', 200);">√ó</span>
        </div>
        <div class="dd-body" id="dd-content">
            </div>
    </div>
</div>

    <div id="modal-overlay" class="modal-overlay">
        <div id="modal-content">
            <div class="modal-header">
                <div style="display:flex; align-items:center; gap:20px;">
                    <h2 id="modal-title">Device List</h2>
                    <input type="text" id="modal-search" placeholder="Search..." onkeyup="renderModalContent()">
                    <button class="control-btn" id="modal-refresh-btn" onclick="refreshModalData()" title="Refresh this list from server">üîÑ Refresh</button>
                    <button class="control-btn" onclick="exportModalCSV()">‚¨áÔ∏è CSV</button>
                    <label style="display:flex; align-items:center; font-size:12px; gap:5px; color:#aaa; cursor:pointer;">
                        <input type="checkbox" id="chk-show-raw" onchange="renderModalContent()"> Show Raw Data
                    </label>
                </div>
                <span class="modal-close" onclick="closeModal()">√ó</span>
            </div>
            <div class="modal-body">
                <table class="detail-table">
                    <thead>
                        <tr>
                            <th onclick="setSort('status')">Status <span id="sort-status"></span></th>
                            <th onclick="setSort('name')">Name <span id="sort-name"></span></th>
                            <th onclick="setSort('ip')">IP Addr <span id="sort-ip"></span></th>
                            <th onclick="setSort('details')">Full Details <span id="sort-details"></span></th>
                            <th onclick="setSort('updatedAt')">Last Check <span id="sort-updatedAt"></span></th>
                        </tr>
                    </thead>
                    <tbody id="modal-rows"></tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="history-modal" class="modal-overlay" style="display:none;">
        <div id="history-modal-content" style="display:flex; align-items:center; justify-content:center; width:100%; height:100%;">
            <div style="background:#1e1e1e; width:92%; max-width:900px; border-radius:12px; border:1px solid #333; box-shadow:0 20px 50px rgba(0,0,0,0.5); overflow:hidden;">
                <div style="padding:20px; border-bottom:1px solid #333; display:flex; justify-content:space-between; align-items:center;">
                    <h2 style="margin:0; font-size:18px; color:#fff;">üìä History details</h2>
                    <span class="modal-close" onclick="closeHistoryModal()" style="cursor:pointer;">√ó</span>
                </div>
                <div style="padding:12px 20px; border-bottom:1px solid #333; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
                    <button class="control-btn" id="hist-btn-24h" onclick="setHistoryPeriod('24h')">24 hours</button>
                    <button class="control-btn" id="hist-btn-7d" onclick="setHistoryPeriod('7d')">7 days</button>
                    <button class="control-btn" id="hist-btn-30d" onclick="setHistoryPeriod('30d')">30 days</button>
                    <button class="control-btn" onclick="exportReport('csv')" title="Export report as CSV">üì• CSV</button>
                    <button class="control-btn" onclick="exportReport('json')" title="Export report as JSON">üì• JSON</button>
                </div>
                <div id="history-detail-body" style="padding:20px; max-height:65vh; overflow-y:auto;">
                    <div style="color:#888;">Loading...</div>
                </div>
            </div>
        </div>
    </div>

    <div id="sidebar-left" class="sidebar">
        <div class="fixed-zone">
            <div class="card card-history" id="card-history">
                <div class="card-header" onclick="openHistoryModal()" style="cursor:pointer;" title="Click for details"><h2>üìä Monitoring history</h2></div>
                <div id="history-content">
                    <div class="history-row clickable" data-period="24h" onclick="openHistoryModal('24h')"><span class="history-period">24 hours</span><span class="history-ok" id="h-24h">‚Äî</span></div>
                    <div class="history-row clickable" data-period="7d" onclick="openHistoryModal('7d')"><span class="history-period">7 days</span><span class="history-ok" id="h-7d">‚Äî</span></div>
                    <div class="history-row clickable" data-period="30d" onclick="openHistoryModal('30d')"><span class="history-period">30 days</span><span class="history-ok" id="h-30d">‚Äî</span></div>
                    <div class="history-ack" id="history-ack-note"></div>
                </div>
            </div>
            <div class="card card-firewall" id="card-firewall">
                <div class="card-header" onclick="openModal('firewall')"><h2>Firewall</h2></div>
                <div id="firewall-latency-row" style="text-align: center; padding-bottom: 15px; border-bottom: 1px solid #333; margin-bottom: 10px;">
                    <span class="big-stat" id="net-ping">--</span><span class="unit" style="display:inline; margin-left:10px;">ms LATENCY</span>
                </div>
                <div id="firewall-content"></div>
            </div>
        </div>
        <div id="left-ticker-mask" class="ticker-mask">
            <div id="left-ticker-content" class="ticker-content">
                <div class="card card-cloud" id="card-cloud">
                    <div class="card-header" onclick="openModal('service')"><h2>Cloud <span class="count-badge" id="c-cloud">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('service', 'cloud-window', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('service', 'cloud-window', this)">üëÅÔ∏è</span></div></div>
                    <div id="cloud-window" class="list-window"></div>
                </div>
                <div class="card card-local" id="card-server">
                    <div class="card-header" onclick="openModal('server')"><h2>Servers <span class="count-badge" id="c-server">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('server', 'server-window', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('server', 'server-window', this)">üëÅÔ∏è</span></div></div>
                    <div id="server-window" class="list-window"></div>
                </div>
                <div class="card card-nvr" id="card-nvr">
                    <div class="card-header" onclick="openModal('nvr')"><h2>NVRs <span class="count-badge" id="c-nvr">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('nvr', 'nvr-list', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('nvr', 'nvr-list', this)">üëÅÔ∏è</span></div></div>
                    <div id="nvr-list" class="list-window"></div>
                </div>
                <div class="card card-esxi" id="card-esxi">
                    <div class="card-header" onclick="openModal('esxi')"><h2>ESXi <span class="count-badge" id="c-esxi">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('esxi', 'esxi-list', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('esxi', 'esxi-list', this)">üëÅÔ∏è</span></div></div>
                    <div id="esxi-list" class="list-window"></div>
                </div>
            </div>
        </div>
        <div class="version-footer">KINGSBURY MONITOR v10.0 | SYSTEM OK</div>
    </div>

    <div id="main-content">
        <div class="page-header">
            <div style="display:flex; align-items:center; gap:12px;">
                <div id="conn-badge" class="badge badge-local" onclick="toggleViewMode()">LOCAL</div>
                <span>Kingsbury IT Monitoring</span>
                <button type="button" class="control-btn" onclick="updateDashboard(); plotDevicesOnMap();" title="Refresh map &amp; devices">üîÑ Refresh</button>
            </div>
            <div id="weather-box" class="weather-box" onclick="openClockThemeModal()" title="Click to change time/date style">
                <div class="weather-main">
                    <span id="clock" class="clock-display">--:--</span>
                    <span id="weather-icon" style="font-size:24px;">‚õÖ</span>
                    <span id="weather-temp" class="weather-temp">--¬∞C</span>
                </div>
                <div class="date-display" id="date-display">Thinking...</div>
            </div>
        </div>
        <div id="clock-theme-modal" class="modal-overlay" style="display:none;">
            <div style="background:#1e1e1e; padding:24px; border-radius:12px; border:1px solid #444; min-width:280px;">
                <h3 style="margin:0 0 16px 0; color:#fff;">Time &amp; date style</h3>
                <p style="font-size:12px; color:#888; margin:0 0 12px 0;">Also changes the map background. Your choice is remembered.</p>
                <div style="display:flex; flex-direction:column; gap:8px;">
                    <button class="control-btn" onclick="setClockTheme('default')">Default</button>
                    <button class="control-btn" onclick="setClockTheme('retro')">Retro / Matrix (with falling code)</button>
                    <button class="control-btn" onclick="setClockTheme('analogue')">Analogue (elegant)</button>
                    <button class="control-btn" onclick="setClockTheme('cartoon')">Cartoon</button>
                </div>
                <button class="control-btn" style="margin-top:16px; width:100%;" onclick="closeClockThemeModal()">Done</button>
            </div>
        </div>
        <div id="map-wrapper" class="map-theme-default">
            <div id="map-bg"></div>
            <div id="map"></div>
            <div id="map-overlay">
                <div id="map-title">Loading...</div>
                <div id="map-controls">
                    <div class="map-controls-labels">
                        <label><input type="checkbox" id="map-labels-toggle" onchange="toggleMapLabels();"> Labels</label>
                        <label><input type="checkbox" id="map-cctv-coverage-toggle" onchange="toggleMapCctvCoverage();"> CCTV</label>
                        <label><input type="checkbox" id="map-wap-coverage-toggle" onchange="toggleMapWapCoverage();"> WAP</label>
                    </div>
                    <div class="map-nav-buttons">
                        <button type="button" class="map-nav-btn" onclick="prevMap()" title="Previous map">‚èÆ</button>
                        <button type="button" class="map-nav-btn pause-btn" id="pause-btn" onclick="togglePause()" title="Pause / Play">‚è∏</button>
                        <button type="button" class="map-nav-btn" onclick="nextMap()" title="Next map">‚è≠</button>
                    </div>
                </div>
            </div>
            <div id="map-matrix-rain" aria-hidden="true"><canvas id="matrix-rain-canvas"></canvas></div>
        </div>
    </div>

    <div id="sidebar-right" class="sidebar">
        <div id="right-ticker-mask" class="ticker-mask">
            <div id="right-ticker-content" class="ticker-content">
                <div class="card card-printer" id="card-printer">
                    <div class="card-header" onclick="openModal('printer')"><h2>Printers <span class="count-badge" id="c-printer">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('printer', 'printer-window', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('printer', 'printer-window', this)">üëÅÔ∏è</span></div></div>
                    <div id="printer-window" class="list-window"></div>
                </div>
                <div class="card card-cctv" id="card-cctv">
                    <div class="card-header" onclick="openModal('cctv')"><h2>Cameras <span class="count-badge" id="c-cctv">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('cctv', 'cctv-list', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('cctv', 'cctv-list', this)">üëÅÔ∏è</span></div></div>
                    <div id="cctv-list" class="list-window"></div>
                </div>
                <div class="card card-switch" id="card-switch">
                    <div class="card-header" onclick="openModal('switch')"><h2>Switches <span class="count-badge" id="c-switch">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('switch', 'switch-window', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('switch', 'switch-window', this)">üëÅÔ∏è</span></div></div>
                    <div id="switch-window" class="list-window"></div>
                </div>
                <div class="card card-wap" id="card-wap">
                    <div class="card-header" onclick="openModal('wap')"><h2>WAPs <span class="count-badge" id="c-wap">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('wap', 'wap-list', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('wap', 'wap-list', this)">üëÅÔ∏è</span></div></div>
                    <div id="wap-list" class="list-window"></div>
                </div>
                <div class="card card-telephone" id="card-telephone">
                    <div class="card-header" onclick="openModal('telephone')"><h2>Phones <span class="count-badge" id="c-tel">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('telephone', 'tel-list', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('telephone', 'tel-list', this)">üëÅÔ∏è</span></div></div>
                    <div id="tel-list" class="list-window"></div>
                </div>
                <div class="card card-access" id="card-access">
                    <div class="card-header" onclick="openModal('access_control')"><h2>Access <span class="count-badge" id="c-access">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('access_control', 'access-list', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('access_control', 'access-list', this)">üëÅÔ∏è</span></div></div>
                    <div id="access-list" class="list-window"></div>
                </div>
                <div class="card card-hardware" id="card-hardware">
                    <div class="card-header" onclick="openModal('hardware')"><h2>Hardware <span class="count-badge" id="c-hw">(0)</span></h2><div class="header-controls"><span class="expand-btn" onclick="event.stopPropagation(); toggleExpand('hardware', 'hardware-list', this)">‚§¢</span><span class="toggle-btn" onclick="event.stopPropagation(); toggleCard('hardware', 'hardware-list', this)">üëÅÔ∏è</span></div></div>
                    <div id="hardware-list" class="list-window"></div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>
    <script>
        // === CONFIGURATION ===
        const CLOUD_URL = 'https://khs-v4w8.onrender.com';
        let isCloudMode = window.location.hostname.includes('render');
        
        // === UI UTILITIES ===
        function updateBadge() { 
            const b = document.getElementById('conn-badge'); 
            b.innerText = isCloudMode ? "CLOUD VIEW" : "LOCAL VIEW"; 
            b.className = isCloudMode ? "badge badge-cloud" : "badge badge-local";
            const lr = document.getElementById('firewall-latency-row');
            if (lr) lr.style.display = isCloudMode ? 'none' : '';
        }
        function toggleViewMode() { isCloudMode = !isCloudMode; updateBadge(); updateDashboard(); }
        
        function updateTime() { 
            const n = new Date(); 
            const clockEl = document.getElementById('clock');
            const dateEl = document.getElementById('date-display');
            if (clockEl) clockEl.innerText = n.toLocaleTimeString([],{hour:'2-digit',minute:'2-digit',second:'2-digit'});
            if (dateEl) dateEl.innerText = n.toLocaleDateString(undefined,{weekday:'long',day:'numeric',month:'short',year:'numeric'});
        }
        setInterval(updateTime,1000); updateTime();
        updateBadge();

        let clockTheme = localStorage.getItem('clockTheme') || 'default';
        function applyClockTheme() {
            const box = document.getElementById('weather-box');
            if (box) {
                box.classList.remove('theme-retro','theme-matrix','theme-analogue','theme-cartoon');
                if (clockTheme && clockTheme !== 'default') box.classList.add('theme-' + clockTheme);
            }
            const wrapper = document.getElementById('map-wrapper');
            if (wrapper) {
                const mapTheme = (clockTheme === 'matrix') ? 'retro' : (clockTheme || 'default');
                wrapper.classList.remove('map-theme-default','map-theme-retro','map-theme-analogue','map-theme-cartoon');
                wrapper.classList.add('map-theme-' + mapTheme);
                if (mapTheme === 'retro') startMatrixRain(); else stopMatrixRain();
            }
        }
        (function initMatrixRain() {
            var matrixRainRaf = null, matrixRainTimeout = null;
            var matrixCtx = null, matrixDrops = [], matrixFontSize = 10, matrixDropSpeed = 0.35, matrixLetters = 'ABCDEFGHIJKLMNOPQRSTUVXYZ0123456789@#$%&*'.split('');
            function resizeMatrixCanvas() {
                var container = document.getElementById('map-matrix-rain');
                var canvas = document.getElementById('matrix-rain-canvas');
                if (!container || !canvas || !matrixCtx) return;
                var w = container.clientWidth, h = container.clientHeight;
                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w;
                    canvas.height = h;
                    var cols = Math.floor(w / matrixFontSize);
                    matrixDrops.length = 0;
                    for (var i = 0; i < cols; i++) matrixDrops[i] = 1;
                }
            }
            function drawMatrix() {
                var canvas = document.getElementById('matrix-rain-canvas');
                if (!canvas || !matrixCtx) return;
                var container = document.getElementById('map-matrix-rain');
                if (!container || container.offsetParent === null) return;
                if (document.hidden) {
                    if (matrixRainRaf) cancelAnimationFrame(matrixRainRaf);
                    matrixRainRaf = null;
                    matrixRainTimeout = setTimeout(drawMatrix, 250);
                    return;
                }
                if (matrixRainTimeout) clearTimeout(matrixRainTimeout);
                matrixRainTimeout = null;
                resizeMatrixCanvas();
                if (canvas.width === 0 || canvas.height === 0 || matrixDrops.length === 0) {
                    matrixRainRaf = requestAnimationFrame(drawMatrix);
                    return;
                }
                matrixCtx.fillStyle = 'rgba(10, 18, 10, 0.12)';
                matrixCtx.fillRect(0, 0, canvas.width, canvas.height);
                matrixCtx.fillStyle = '#0f0';
                matrixCtx.font = matrixFontSize + 'px monospace';
                for (var i = 0; i < matrixDrops.length; i++) {
                    var ch = matrixLetters[Math.floor(Math.random() * matrixLetters.length)];
                    matrixCtx.fillText(ch, i * matrixFontSize, matrixDrops[i] * matrixFontSize);
                    matrixDrops[i] += matrixDropSpeed;
                    if (matrixDrops[i] * matrixFontSize > canvas.height && Math.random() > 0.95) matrixDrops[i] = 0;
                }
                matrixRainRaf = requestAnimationFrame(drawMatrix);
            }
            window.startMatrixRain = function() {
                stopMatrixRain();
                var canvas = document.getElementById('matrix-rain-canvas');
                var container = document.getElementById('map-matrix-rain');
                if (!canvas || !container) return;
                matrixCtx = canvas.getContext('2d');
                resizeMatrixCanvas();
                matrixRainRaf = requestAnimationFrame(drawMatrix);
            };
            window.stopMatrixRain = function() {
                if (matrixRainRaf) { cancelAnimationFrame(matrixRainRaf); matrixRainRaf = null; }
                if (matrixRainTimeout) { clearTimeout(matrixRainTimeout); matrixRainTimeout = null; }
                matrixCtx = null;
            };
            var ro = typeof ResizeObserver !== 'undefined' ? new ResizeObserver(function() { if (matrixCtx) resizeMatrixCanvas(); }) : null;
            document.addEventListener('DOMContentLoaded', function() {
                var el = document.getElementById('map-matrix-rain');
                if (el && ro) ro.observe(el);
            });
            if (document.readyState !== 'loading' && ro) {
                var el = document.getElementById('map-matrix-rain');
                if (el) ro.observe(el);
            }
        })();
        function openClockThemeModal() {
            document.getElementById('clock-theme-modal').style.display = 'flex';
            document.getElementById('clock-theme-modal').classList.add('active');
        }
        function closeClockThemeModal() {
            document.getElementById('clock-theme-modal').classList.remove('active');
            document.getElementById('clock-theme-modal').style.display = 'none';
        }
        function setClockTheme(theme) {
            clockTheme = theme;
            localStorage.setItem('clockTheme', theme);
            applyClockTheme();
            closeClockThemeModal();
        }
        applyClockTheme();
        document.getElementById('clock-theme-modal') && document.getElementById('clock-theme-modal').addEventListener('click', function(e) { if (e.target.id === 'clock-theme-modal') closeClockThemeModal(); });

        function formatNoteForDisplay(note) {
            if (!note || typeof note !== 'string') return note;
            const t = note.trim();
            if (/^HTTP\s*OK$/i.test(t)) return 'Website online (HTTP 200)';
            if (/^Ping\s*Only$/i.test(t)) return 'Reachable (ping only ‚Äî no HTTP check)';
            if (/^Website\s*online\s*\(HTTP\s*\d+\)$/i.test(t)) return t;
            if (/Reachable\s*\(ping\s*only/i.test(t)) return t;
            return note;
        }

        async function exportReport(format) {
            const base = isCloudMode ? CLOUD_URL : '';
            try {
                const r = await fetch(base + '/api/report?format=' + (format || 'json'));
                if (!r.ok) throw new Error('Export failed');
                const filename = 'monitor-report-' + Date.now() + (format === 'csv' ? '.csv' : '.json');
                if (format === 'csv') {
                    const blob = await r.blob();
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(a.href);
                } else {
                    const data = await r.json();
                    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(a.href);
                }
            } catch (e) { console.error(e); }
        }

        async function fetchWeather() { 
            try{ 
                const r = await fetch('https://api.open-meteo.com/v1/forecast?latitude=51.6132&longitude=-0.2755&current_weather=true'); 
                const d = await r.json(); 
                document.getElementById('weather-temp').innerText = `${Math.round(d.current_weather.temperature)}¬∞C`; 
            }catch(e){} 
        }
        fetchWeather(); setInterval(fetchWeather,600000);

        function safeParseDetails(d) { 
            if(!d) return {}; 
            if(typeof d==='object') return d; 
            try{ 
                const p = JSON.parse(d); 
                if(typeof p==='string') return safeParseDetails(p); 
                return p; 
            }catch(e){ return {}; } 
        }

        function formatSeenFor(upSince) {
            if (!upSince) return '';
            const then = new Date(upSince).getTime();
            if (isNaN(then)) return '';
            const sec = Math.floor((Date.now() - then) / 1000);
            if (sec < 0) return '';
            if (sec >= 86400) return 'Seen for ' + Math.floor(sec / 86400) + 'd';
            if (sec >= 3600) return 'Seen for ' + Math.floor(sec / 3600) + 'h';
            if (sec >= 60) return 'Seen for ' + Math.floor(sec / 60) + 'm';
            return 'Seen for <1m';
        }

        function getCameraDisplayDetails(obj) {
            if (!obj) return {};
            const o = {};
            if (obj.sysName && String(obj.sysName).trim() !== 'Device' && String(obj.sysName).trim().toLowerCase() !== 'unknown') o.sysName = obj.sysName;
            if (obj.uptime && String(obj.uptime).trim() !== '?') o.uptime = obj.uptime;
            if (obj.model) o.model = obj.model;
            if (obj.Model) o.Model = obj.Model;
            if (obj.serial) o.serial = obj.serial;
            if (obj.mac) o.mac = obj.mac;
            if (obj.note && String(obj.note).trim()) {
                const n = String(obj.note)
                    .replace(/\|\s*Uptime:\s*[^|]+/gi, '')
                    .replace(/\|\s*Seen for [^|]+/gi, '')
                    .replace(/\|\s*$/g, '').trim();
                if (n) o.note = n;
            }
            if (obj.Total_Recv && String(obj.Total_Recv) !== '0.00 GB') o.Total_Recv = obj.Total_Recv;
            if (obj.Total_Sent && String(obj.Total_Sent) !== '0.00 GB') o.Total_Sent = obj.Total_Sent;
            if (obj.cpu != null && obj.cpu > 0) o.cpu = obj.cpu;
            if (obj.ram != null && obj.ram > 0) o.ram = obj.ram;
            if (obj.disk != null && obj.disk > 0) o.disk = obj.disk;
            if (obj.HikvisionDiskSize && String(obj.HikvisionDiskSize).trim()) o.HikvisionDiskSize = obj.HikvisionDiskSize;
            if (obj.HikvisionMemSize && String(obj.HikvisionMemSize).trim()) o.HikvisionMemSize = obj.HikvisionMemSize;
            if (obj.HikvisionSysTime && String(obj.HikvisionSysTime).trim()) o.HikvisionSysTime = obj.HikvisionSysTime;
            return o;
        }

        // === CARD VISIBILITY ===
        let globalCardConfig={}; 
        let displayLabelsConfig = {};
        async function loadGlobalConfig(){ 
            try{ const r=await fetch('/api/card-config'); if(r.ok){ globalCardConfig=await r.json(); applyGlobalVisibility(); } }catch(e){} 
            try{ const r=await fetch('/api/display-labels-config'); if(r.ok) displayLabelsConfig=await r.json(); }catch(e){}
        }
        function shouldShowLabel(deviceType, labelKey) {
            const arr = displayLabelsConfig[deviceType];
            if (!arr || !Array.isArray(arr) || arr.length === 0) return true;
            return arr.includes(labelKey);
        }
        function applyGlobalVisibility() { 
            const m={'card-cloud':'cloud','card-server':'server','card-nvr':'nvr','card-esxi':'esxi','card-printer':'printer','card-cctv':'cctv','card-switch':'switch','card-wap':'wap','card-telephone':'telephone','card-access':'access','card-hardware':'hardware','card-firewall':'firewall'}; 
            Object.keys(m).forEach(id=>{ 
                const k=m[id]; const el=document.getElementById(id); 
                if(el){ 
                    if(globalCardConfig[k]===false){ el.classList.add('gone'); if(k==='firewall') el.parentNode.style.display='none'; }
                    else{ el.classList.remove('gone'); if(k==='firewall') el.parentNode.style.display='block'; } 
                } 
            });
            plotDevicesOnMap(); 
        }

        const hiddenTypes = new Set(JSON.parse(localStorage.getItem('hiddenTypes')||'[]')); 
        const expandedTypes = new Set(JSON.parse(localStorage.getItem('expandedTypes')||'[]'));

        function getUiType(d) { 
            if(!d) return 'unknown'; 
            let t = "";
            let name = "";
            
            // Handle object or string input
            if(typeof d === 'string') { t = d.toLowerCase().trim(); }
            else { t = (d.type || "").toLowerCase().trim(); name = (d.name || "").toLowerCase().trim(); }

            // FIX: Robust check for switches. Even if type is 'hardware', if name says 'switch', categorize as switch.
            if(t === 'switch' || t === 'network' || name.includes('switch')) return 'switch'; 
            
            if(t==='san'||t==='nas'||t.includes('storage')) return 'hardware'; 
            if(t==='access'||t.includes('access')) return 'access_control'; 
            if(t==='service'||t==='cloud') return 'service'; 
            return t; 
        }

        function toggleCard(t,e,b) { 
            const el=document.getElementById(e); 
            if(!el) return; 
            if(hiddenTypes.has(t)){ 
                hiddenTypes.delete(t); el.classList.remove('minimized'); b.classList.remove('hidden-active'); 
                el.parentNode.querySelector('.expand-btn').classList.remove('force-hide'); 
            }else{ 
                hiddenTypes.add(t); el.classList.add('minimized'); b.classList.add('hidden-active'); 
                el.parentNode.querySelector('.expand-btn').classList.add('force-hide'); 
            } 
            localStorage.setItem('hiddenTypes',JSON.stringify([...hiddenTypes])); 
            updateDashboard();
            plotDevicesOnMap();
        }

        function toggleExpand(t,e,b) { 
            const el=document.getElementById(e); 
            if(!el) return; 
            if(expandedTypes.has(t)){ 
                expandedTypes.delete(t); el.classList.remove('expanded'); b.classList.remove('expanded-active'); 
            }else{ 
                expandedTypes.add(t); el.classList.add('expanded'); b.classList.add('expanded-active'); 
            } 
            localStorage.setItem('expandedTypes',JSON.stringify([...expandedTypes])); 
        }

        // === SCROLLING & TICKERS ===
        let sidebarPaused=false; 
        function setupInfiniteTicker(m,c){ 
            const mk=document.getElementById(m), ct=document.getElementById(c); 
            let y=0, s=0.5; 
            mk.addEventListener('mouseenter',()=>sidebarPaused=true); 
            mk.addEventListener('mouseleave',()=>sidebarPaused=false); 
            function loop(){ 
                if(sidebarPaused) return requestAnimationFrame(loop); 
                let h=0; 
                Array.from(ct.children).forEach(c=>{ if(getComputedStyle(c).display!=='none'&&!c.classList.contains('gone')) h+=c.offsetHeight+20; }); 
                if(h<=mk.offsetHeight+5){ y=0; ct.style.transform='translateY(0px)'; return requestAnimationFrame(loop); } 
                y-=s; 
                let f=ct.firstElementChild; 
                while(f&&(getComputedStyle(f).display==='none'||f.classList.contains('gone'))){ ct.appendChild(f); f=ct.firstElementChild; } 
                if(f&&Math.abs(y)>=f.offsetHeight+20){ y+=f.offsetHeight+20; ct.appendChild(f); } 
                ct.style.transform=`translateY(${y}px)`; 
                requestAnimationFrame(loop); 
            } 
            setTimeout(()=>requestAnimationFrame(loop),2000); 
        }
        setupInfiniteTicker('left-ticker-mask','left-ticker-content'); 
        setupInfiniteTicker('right-ticker-mask','right-ticker-content');

        let internalScrollStates={}; 
        function startInternalScroll(){ 
            setInterval(()=>{ 
                document.querySelectorAll('.list-window').forEach(d=>{ 
                    if(d.classList.contains('minimized')||d.classList.contains('expanded')) return; 
                    if(d.scrollHeight<=d.clientHeight) return; 
                    const id=d.id; 
                    if(!internalScrollStates[id]) internalScrollStates[id]={dir:1,pause:0}; 
                    const s=internalScrollStates[id]; 
                    if(s.pause>0){ s.pause-=50; return; } 
                    d.scrollTop+=s.dir; 
                    if(Math.ceil(d.scrollTop+d.clientHeight)>=d.scrollHeight){ s.dir=-1; s.pause=2000; }
                    else if(d.scrollTop<=0){ s.dir=1; s.pause=2000; } 
                }); 
            },50); 
        }

        // === MAPS ===
        let maps=[{id:'T-G.PNG',name:'T Site - Ground',active:true}]; 
        var map=L.map('map',{crs:L.CRS.Simple,minZoom:-2,zoomControl:false,attributionControl:false});
        if (!map.getPane('labelsPane')) {
            map.createPane('labelsPane');
            map.getPane('labelsPane').style.zIndex = 650;
        }
        function ensureMapBgVisible(){ var m=document.getElementById('map'); if(m){ m.style.setProperty('background','transparent','important'); } var c=document.querySelector('#map-wrapper .leaflet-container'); if(c){ c.style.setProperty('background','transparent','important'); } }
        ensureMapBgVisible();
        map.whenReady(ensureMapBgVisible);
        var devicesLayer=L.layerGroup().addTo(map); 
        var deviceLabelsLayer = L.layerGroup().addTo(map);
        var cameraConesLayer = L.layerGroup().addTo(map);
        var locateHighlightLayer = L.layerGroup().addTo(map);
        var currentMapLayer; 
        let currentMapIndex=0, isPaused=false;
        let locateDeviceAfterLoad = null;
        
        async function loadMapConfig(){ 
            try{
                const r=await fetch('/api/map-config');
                if(r.ok) {
                    const allMaps = await r.json();
                    maps = allMaps.filter(m => m.active !== false);
                    if(maps.length === 0) maps = [{id:'T-G.PNG', name:'T Site - Ground', active:true}];
                }
            }catch(e){
                console.error('Failed to load map config:', e);
            } 
            loadMap(0); 
        }
        function prevMap(){ currentMapIndex=(currentMapIndex-1+maps.length)%maps.length; loadMap(currentMapIndex); }
        function nextMap(){ currentMapIndex=(currentMapIndex+1)%maps.length; loadMap(currentMapIndex); }
        let mapLabelsVisible = false;
        let mapCctvCoverageVisible = false;
        let mapWapCoverageVisible = false;
        function toggleMapLabels(){ mapLabelsVisible=!!(document.getElementById('map-labels-toggle')&&document.getElementById('map-labels-toggle').checked); try{ localStorage.setItem('mapLabelsVisible', mapLabelsVisible ? 'true' : 'false'); }catch(e){} plotDevicesOnMap(); }
        function toggleMapCctvCoverage(){ mapCctvCoverageVisible=!!(document.getElementById('map-cctv-coverage-toggle')&&document.getElementById('map-cctv-coverage-toggle').checked); try{ localStorage.setItem('mapCctvCoverageVisible', mapCctvCoverageVisible ? 'true' : 'false'); }catch(e){} plotDevicesOnMap(); }
        function toggleMapWapCoverage(){ mapWapCoverageVisible=!!(document.getElementById('map-wap-coverage-toggle')&&document.getElementById('map-wap-coverage-toggle').checked); try{ localStorage.setItem('mapWapCoverageVisible', mapWapCoverageVisible ? 'true' : 'false'); }catch(e){} plotDevicesOnMap(); }
        function loadMap(i){ 
            currentMapIndex = i;
            devicesLayer.clearLayers();
            deviceLabelsLayer.clearLayers();
            cameraConesLayer.clearLayers();
            const c=maps[i]; 
            if (!c) return;
            document.getElementById('map-title').innerText=c.name; 
            var img=new Image();
            function applyMap(){
                var h = img.naturalHeight || img.height || 0, w = img.naturalWidth || img.width || 0;
                if (h <= 0 || w <= 0) { h = 800; w = 1000; }
                var b=[[0,0],[h,w]]; 
                if(currentMapLayer) map.removeLayer(currentMapLayer); 
                currentMapLayer=L.imageOverlay(c.id,b).addTo(map);
                map.invalidateSize();
                map.fitBounds(b, { animate: false, padding: [0, 0], maxZoom: 19 });
                ensureMapBgVisible();
                plotDevicesOnMap();
                if (locateDeviceAfterLoad) {
                    addRadarPing(locateDeviceAfterLoad);
                    locateDeviceAfterLoad = null;
                }
                setTimeout(function(){ map.invalidateSize(); plotDevicesOnMap(); }, 50);
            }
            img.onload=applyMap;
            img.onerror=function(){ applyMap(); };
            img.src = c.id.startsWith('/') ? c.id : '/' + c.id;
            if (img.complete && (img.naturalWidth || img.width)) applyMap();
        }

        function deviceIsLocatable(d) {
            if (!d) return false;
            const fid = (d.floor_id || '').toString().trim().toLowerCase();
            if (!fid || fid === 'nomap') return false;
            let x = null, y = null;
            if (d.map_coordinates && typeof d.map_coordinates === 'object') {
                x = parseFloat(d.map_coordinates.x);
                y = parseFloat(d.map_coordinates.y);
            } else if (d.x !== undefined && d.y !== undefined) {
                x = parseFloat(d.x);
                y = parseFloat(d.y);
            }
            if (x == null || y == null) return false;
            if (x === 0 && y === 0) return false;
            return true;
        }

        function addRadarPing(d) {
            locateHighlightLayer.clearLayers();
            let x, y;
            if (d.map_coordinates && typeof d.map_coordinates === 'object') { x = parseFloat(d.map_coordinates.x); y = parseFloat(d.map_coordinates.y); }
            else { x = parseFloat(d.x); y = parseFloat(d.y); }
            const icon = L.divIcon({
                className: 'radar-ping-wrap',
                html: '<div class="radar-ping-ring"></div><div class="radar-ping-ring"></div><div class="radar-ping-ring"></div>',
                iconSize: [80, 80],
                iconAnchor: [40, 40]
            });
            const pingMarker = L.marker([y, x], { icon: icon });
            pingMarker.addTo(locateHighlightLayer);
            map.panTo([y, x], { animate: true, duration: 0.3 });
            setTimeout(function() { locateHighlightLayer.removeLayer(pingMarker); }, 4500);
        }

        function locateDeviceOnMap(ip) {
            const d = cachedDevices.find(dev => dev.ip === ip);
            if (!d || !deviceIsLocatable(d)) return;
            isPaused = true;
            const btn = document.getElementById('pause-btn');
            if (btn) btn.innerText = '‚ñ∂';
            const fid = String(d.floor_id || '').trim().toLowerCase().replace(/\.(png|jpg|jpeg|gif|webp)$/i, '');
            const mapIdx = maps.findIndex(m => String(m.id || '').trim().toLowerCase().replace(/\.(png|jpg|jpeg|gif|webp)$/i, '') === fid);
            if (mapIdx >= 0) {
                if (currentMapIndex === mapIdx) {
                    addRadarPing(d);
                } else {
                    currentMapIndex = mapIdx;
                    locateDeviceAfterLoad = d;
                    loadMap(currentMapIndex);
                }
            }
            document.getElementById('device-detail-modal').classList.remove('active');
            document.getElementById('device-detail-modal').style.display = 'none';
        }

        // === DEVICE MARKERS ===
        const deviceEmojis = {
            'server': 'üñ•Ô∏è', 'esxi': 'üóÑÔ∏è', 'nvr': 'üìπ', 'firewall': 'üõ°Ô∏è', 'switch': null,
            'wap': null, 'printer': 'üñ®Ô∏è', 'cctv': null, 'telephone': '‚òè', 'access_control': 'üö™',
            'hardware': 'üíæ', 'service': '‚òÅÔ∏è', 'cloud': '‚òÅÔ∏è', 'default': 'üìç'
        };
        const deviceIconImages = { 'switch': '/images/network-switch.png', 'cctv': '/images/camera.png', 'wap': '/images/wap.png' };
        
        function getDeviceIcon(type, size) {
            const t = getUiType({type: type});
            const imgSrc = deviceIconImages[t];
            if (imgSrc) {
                const s = (typeof size === 'number') ? size + 'px' : (size || '1.1em');
                return `<img src="${imgSrc}" alt="" class="device-type-icon" style="width:${s};height:${s};vertical-align:middle;object-fit:contain;display:inline-block;">`;
            }
            const emoji = deviceEmojis[t] || deviceEmojis['default'];
            if (typeof size === 'string' && size.endsWith('em')) return `<span style="font-size:${size};">${emoji}</span>`;
            return emoji;
        }
        function getDeviceEmoji(type) {
            const t = getUiType({type: type});
            return deviceEmojis[t] || deviceEmojis['default'];
        }

        // Convex hull (Graham scan) - points as [y, x] for Leaflet; returns ordered hull [y,x]...
        function convexHull(points) {
            if (points.length < 3) return points.slice();
            const pts = points.map(p => [parseFloat(p[0]), parseFloat(p[1])]);
            let minIdx = 0;
            for (let i = 1; i < pts.length; i++) {
                if (pts[i][0] < pts[minIdx][0] || (pts[i][0] === pts[minIdx][0] && pts[i][1] < pts[minIdx][1])) minIdx = i;
            }
            const start = pts[minIdx];
            const rest = pts.filter((_, i) => i !== minIdx).map(p => ({
                p,
                angle: Math.atan2(p[1] - start[1], p[0] - start[0]),
                dist: (p[0] - start[0]) ** 2 + (p[1] - start[1]) ** 2
            }));
            rest.sort((a, b) => a.angle !== b.angle ? a.angle - b.angle : a.dist - b.dist);
            const hull = [start, rest[0].p];
            for (let i = 1; i < rest.length; i++) {
                const next = rest[i].p;
                while (hull.length >= 2) {
                    const a = hull[hull.length - 2], b = hull[hull.length - 1];
                    const cross = (b[0] - a[0]) * (next[1] - b[1]) - (b[1] - a[1]) * (next[0] - b[0]);
                    if (cross <= 0) hull.pop();
                    else break;
                }
                hull.push(next);
            }
            return hull;
        }

        // Cluster problem devices by proximity (same area). Returns array of device arrays.
        const FAULT_CLUSTER_RADIUS = 120;
        const FAULT_MIN_DEVICES = 2;
        function getDeviceTooltipHtml(d) {
            const esc = (s) => (s || '').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
            const name = esc(d.name || 'Device');
            const ip = esc(d.ip || '');
            const det = safeParseDetails(d.details);
            const note = (det && det.note) ? String(det.note) : '';
            const t = getUiType(d);
            let html = '<div class="device-tt-name">' + name + '</div><div class="device-tt-ip">' + ip + '</div>';
            if (t === 'printer' && note) {
                const tr = /([CMYK]):(\w+)%?/g; let m; const ts = {};
                while ((m = tr.exec(note)) !== null) { ts[m[1]] = m[2] === 'OK' ? 100 : parseInt(m[2], 10); }
                let cleanNote = note.replace(/([CMYK]):\w+%?/g, '').replace(/\|/g, '').trim();
                const errorMsg = (cleanNote.length > 2 && !cleanNote.includes('OK')) ? cleanNote : '';
                if (Object.keys(ts).length > 0) {
                    const supplyStr = ['C','M','Y','K'].filter(c=>ts[c]!==undefined).map(c=>c+':'+(ts[c]===100?'OK':ts[c]+'%')).join(' ');
                    html += '<div class="device-tt-extra" style="margin-top:6px;font-size:11px;color:#aaa;">' + esc(supplyStr) + '</div>';
                }
                if (errorMsg) html += '<div class="device-tt-warn" style="margin-top:4px;font-size:11px;color:#ffc107;">‚ö†Ô∏è ' + esc(errorMsg) + '</div>';
            } else if (t === 'wap' || t === 'wifi' || t === 'ap') {
                const clientsMatch = note.match(/Clients?:\s*(\d+)/i);
                if (clientsMatch) html += '<div class="device-tt-extra" style="margin-top:6px;font-size:11px;color:#aaa;">' + clientsMatch[1] + ' clients</div>';
            }
            return html;
        }

        function clusterProblemDevices(problemDevices) {
            const withPos = problemDevices.map(d => {
                let x, y;
                if (d.map_coordinates && typeof d.map_coordinates === 'object') { x = parseFloat(d.map_coordinates.x); y = parseFloat(d.map_coordinates.y); }
                else { x = parseFloat(d.x); y = parseFloat(d.y); }
                return { d, x, y, key: `${y},${x}` };
            });
            const parent = {};
            withPos.forEach((_, i) => parent[i] = i);
            function find(i) { return parent[i] === i ? i : (parent[i] = find(parent[i])); }
            function union(i, j) { parent[find(i)] = find(j); }
            const R2 = FAULT_CLUSTER_RADIUS * FAULT_CLUSTER_RADIUS;
            for (let i = 0; i < withPos.length; i++) {
                for (let j = i + 1; j < withPos.length; j++) {
                    const dy = withPos[i].y - withPos[j].y, dx = withPos[i].x - withPos[j].x;
                    if (dy * dy + dx * dx <= R2) union(i, j);
                }
            }
            const groups = {};
            withPos.forEach((w, i) => {
                const r = find(i);
                if (!groups[r]) groups[r] = [];
                groups[r].push(w);
            });
            return Object.values(groups).filter(g => g.length >= FAULT_MIN_DEVICES);
        }

        function formatLastIssue(d) {
            const t = d.last_issue || d.last_seen || d.updatedAt;
            if (!t) return '‚Äî';
            const dt = new Date(t);
            const now = Date.now();
            const diff = (now - dt) / 60000;
            if (diff < 60) return dt.toLocaleTimeString() + ' (' + Math.round(diff) + 'm ago)';
            if (diff < 1440) return dt.toLocaleTimeString() + ' (' + Math.round(diff / 60) + 'h ago)';
            return dt.toLocaleString();
        }

        // Cluster devices by map position (same or very close). Returns Map<key, { devices, cx, cy, sameType, typeName }>.
        const LABEL_GRID = 28;
        const OVERLAP_GRID = 5;
        function clusterMapDevicesByPosition(mapDevices, gridSize) {
            const grid = gridSize || LABEL_GRID;
            const keyToDevices = new Map();
            mapDevices.forEach(d => {
                let x, y;
                if (d.map_coordinates && typeof d.map_coordinates === 'object') { x = parseFloat(d.map_coordinates.x); y = parseFloat(d.map_coordinates.y); }
                else { x = parseFloat(d.x); y = parseFloat(d.y); }
                const key = `${Math.round(x / grid)}_${Math.round(y / grid)}`;
                if (!keyToDevices.has(key)) keyToDevices.set(key, []);
                keyToDevices.get(key).push({ d, x, y });
            });
            const result = new Map();
            keyToDevices.forEach((arr, key) => {
                const cx = arr.reduce((s, w) => s + w.x, 0) / arr.length;
                const cy = arr.reduce((s, w) => s + w.y, 0) / arr.length;
                const types = [...new Set(arr.map(w => getUiType(w.d)))];
                const sameType = types.length === 1 && arr.length > 1;
                const typeName = types[0] ? (types[0].charAt(0).toUpperCase() + types[0].slice(1).replace(/_/g, ' ')) : 'Device';
                result.set(key, { devices: arr, cx, cy, sameType, typeName });
            });
            return result;
        }

        function plotDevicesOnMap() {
            mapLabelsVisible = !!(document.getElementById('map-labels-toggle') && document.getElementById('map-labels-toggle').checked);
            mapCctvCoverageVisible = !!(document.getElementById('map-cctv-coverage-toggle') && document.getElementById('map-cctv-coverage-toggle').checked);
            mapWapCoverageVisible = !!(document.getElementById('map-wap-coverage-toggle') && document.getElementById('map-wap-coverage-toggle').checked);
            devicesLayer.clearLayers();
            deviceLabelsLayer.clearLayers();
            cameraConesLayer.clearLayers();
            const currentMap = maps[currentMapIndex];
            if (!currentMap || !cachedDevices.length) return;
            
            function normalizeFloorId(id) {
                const s = String(id || '').trim().toLowerCase();
                if (!s || s === 'nomap') return '';
                return s.replace(/\.(png|jpg|jpeg|gif|webp)$/i, '');
            }
            const currentMapNorm = normalizeFloorId(currentMap.id);
            const mapDevices = cachedDevices.filter(d => {
                if (!d.floor_id || d.floor_id === 'nomap') return false;
                const deviceType = getUiType(d);
                if (hiddenTypes.has(deviceType)) return false;
                const cardConfigKey = deviceType === 'service' ? 'cloud' : deviceType;
                if (globalCardConfig[cardConfigKey] === false) return false;
                
                let x, y;
                if (d.map_coordinates && typeof d.map_coordinates === 'object') { x = d.map_coordinates.x; y = d.map_coordinates.y; } 
                else if (d.x !== undefined && d.y !== undefined) { x = d.x; y = d.y; }
                
                if (x === undefined || y === undefined || (x === 0 && y === 0)) return false;
                const deviceFloorNorm = normalizeFloorId(d.floor_id);
                if (!deviceFloorNorm) return false;
                return deviceFloorNorm === currentMapNorm;
            });

            const positionClusters = clusterMapDevicesByPosition(mapDevices);
            const overlapClusters = clusterMapDevicesByPosition(mapDevices, OVERLAP_GRID);
            const ackIps = new Set(acknowledgedIssues.map(a => (a.ip || a.deviceIp || '').trim()).filter(Boolean));
            const problemDevices = mapDevices.filter(d => (d.status === 'offline' || d.status === 'amber') && !ackIps.has((d.ip || '').trim()));

            // 1. Same-type overlapping groups: use tight grid so only truly overlapping devices (same position) cluster. Highlight when at least one has an ongoing problem.
            overlapClusters.forEach(cluster => {
                if (!cluster.sameType || cluster.devices.length < 2) return;
                const hasOngoingProblem = cluster.devices.some(w => {
                    const d = w.d;
                    const isProblem = d.status === 'offline' || d.status === 'amber' || (d.status === 'online' && deviceHasDriveWarning(d));
                    return isProblem && !ackIps.has((d.ip || '').trim());
                });
                if (!hasOngoingProblem) return;
                const cy = cluster.cy, cx = cluster.cx;
                const deviceList = cluster.devices.map(w => (w.d.name || w.d.ip || 'Device').replace(/</g,'&lt;').replace(/>/g,'&gt;')).join(', ');
                const circle = L.circleMarker([cy, cx], {
                    radius: 38,
                    color: '#4a9eff',
                    fillColor: '#4a9eff',
                    fillOpacity: 0.12,
                    weight: 2,
                    dashArray: '6,4'
                });
                circle.bindTooltip('<div class="device-marker-tooltip-content"><strong>' + cluster.devices.length + '√ó ' + cluster.typeName + '</strong><br><span style="font-size:11px;color:#888;">' + deviceList + '</span><br><span style="font-size:10px;color:#ffc107;">One or more need attention</span></div>', { permanent: false, direction: 'top', className: 'device-marker-tooltip', offset: [0, -8] });
                circle.addTo(devicesLayer);
                cluster.devices.forEach((w, idx) => {
                    var offset = 0;
                    if (cluster.devices.length > 1) offset = (idx - (cluster.devices.length - 1) / 2) * 12;
                    var ghostX = cluster.devices.length > 1 ? cx + offset : cx;
                    var ghostY = cluster.devices.length > 1 ? cy - Math.abs(offset) * 0.5 : cy;
                    var nm = (w.d.name || w.d.ip || '?').replace(/</g,'&lt;').replace(/>/g,'&gt;');
                    var ghostIcon = L.divIcon({
                        className: 'device-map-ghost',
                        html: '<span style="font-size:10px;background:rgba(74,158,255,0.9);color:#fff;padding:2px 5px;border-radius:4px;white-space:nowrap;">' + nm + '</span>',
                        iconSize: [50, 16],
                        iconAnchor: [25, 16]
                    });
                    var ghostMarker = L.marker([ghostY, ghostX], { icon: ghostIcon, pane: 'labelsPane' });
                    ghostMarker.bindTooltip(nm + (w.d.ip ? ' (' + w.d.ip + ')' : ''), { permanent: false, direction: 'top', className: 'device-marker-tooltip' });
                    ghostMarker.addTo(deviceLabelsLayer);
                });
                if (mapLabelsVisible) {
                    const labelText = cluster.devices.length + '√ó ' + cluster.typeName;
                    const icon = L.divIcon({
                        className: 'device-map-label group',
                        html: '<span style="color:#000!important;background:#fff!important;">' + (labelText.replace(/</g,'&lt;').replace(/>/g,'&gt;')) + '</span>',
                        iconSize: [50, 14],
                        iconAnchor: [25, 14]
                    });
                    const labelMarker = L.marker([cy - 12, cx], { icon: icon, pane: 'labelsPane' });
                    labelMarker.addTo(deviceLabelsLayer);
                }
            });

            // 2. Fault zones (2+ problem devices in same area)
            const clusters = clusterProblemDevices(problemDevices);
            const PAD = 25;
            clusters.forEach(cluster => {
                const points = cluster.map(w => [w.y, w.x]);
                const hull = convexHull(points);
                if (hull.length < 2) return;
                const centroidY = hull.reduce((s, p) => s + p[0], 0) / hull.length;
                const centroidX = hull.reduce((s, p) => s + p[1], 0) / hull.length;
                const padded = hull.map(([py, px]) => {
                    const dy = py - centroidY, dx = px - centroidX;
                    const scale = 1 + PAD / (Math.hypot(dy, dx) || 1);
                    return [centroidY + dy * scale, centroidX + dx * scale];
                });
                const latLngs = padded.map(([py, px]) => [py, px]);
                const poly = L.polygon(latLngs, {
                    color: '#f8312f',
                    fillColor: '#f8312f',
                    fillOpacity: 0.18,
                    weight: 2,
                    dashArray: '6,4'
                });
                const latestIssue = cluster.reduce((best, w) => {
                    const t = w.d.last_issue || w.d.last_seen || w.d.updatedAt;
                    return (!best || (t && new Date(t) > new Date(best))) ? t : best;
                }, null);
                const label = `${cluster.length} devices down ‚Ä¢ Last: ${formatLastIssue({ last_issue: latestIssue, last_seen: latestIssue, updatedAt: latestIssue })}`;
                poly.bindTooltip(label, { permanent: true, direction: 'center', className: 'fault-zone-label', offset: [0, 0] });
                poly.addTo(devicesLayer);
            });

            // 3. Individual problem circles and markers
            mapDevices.forEach(d => {
                let x, y;
                if (d.map_coordinates && typeof d.map_coordinates === 'object') { x = parseFloat(d.map_coordinates.x); y = parseFloat(d.map_coordinates.y); } 
                else { x = parseFloat(d.x); y = parseFloat(d.y); }
                
                let statusColor = '#00d26a'; let statusClass = 'marker-online';
                if (d.status === 'offline') { statusColor = '#f8312f'; statusClass = 'marker-offline'; } 
                else if (d.status === 'amber') { statusColor = '#ffc107'; statusClass = 'marker-amber'; }
                else if (d.status === 'online' && deviceHasDriveWarning(d)) { statusColor = '#ffc107'; statusClass = 'marker-amber'; }
                
                const isProblem = d.status === 'offline' || d.status === 'amber' || (d.status === 'online' && deviceHasDriveWarning(d));
                const isAcknowledged = isProblem && ackIps.has((d.ip || '').trim());
                if (isAcknowledged) statusClass = statusClass + ' marker-acknowledged';

                const t = getUiType(d);
                let size = 30;
                if (['server', 'nvr', 'esxi', 'firewall'].includes(t)) size = 34;
                if (['cctv'].includes(t)) size = 26;
                const iconHtml = getDeviceIcon(d.type, size);
                
                if (isProblem && !isAcknowledged) {
                    const circle = L.circleMarker([y, x], { radius: 26, color: '#f8312f', fillColor: '#f8312f', fillOpacity: 0.2, weight: 2, dashArray: '4,4' });
                    circle.addTo(devicesLayer);
                }

                const icon = L.divIcon({
                    className: 'device-marker-wrapper',
                    html: `<div class="device-marker-emoji ${statusClass}" style="font-size: ${size}px; text-shadow: 0 0 8px ${statusColor}, 0 0 12px ${statusColor}; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); cursor: pointer; transition: transform 0.2s;">${iconHtml}</div>`,
                    iconSize: [size, size], iconAnchor: [size/2, size/2]
                });
                
                const marker = L.marker([y, x], { icon: icon });
                marker.on('click', () => openDeviceModal(d.ip));
                marker.bindTooltip(getDeviceTooltipHtml(d), { permanent: false, direction: 'top', className: 'device-marker-tooltip', offset: [0, -12] });
                marker.addTo(devicesLayer);
            });

            // 3b. CCTV coverage cones (when toggle on)
            if (mapCctvCoverageVisible) {
                try {
                    var b = map.getBounds();
                    if (b && b.getNorthEast && b.getSouthWest) {
                        var mapH = b.getNorthEast().lat - b.getSouthWest().lat;
                        var mapW = b.getNorthEast().lng - b.getSouthWest().lng;
                        var coneDist = Math.min(mapH, mapW) * 0.08;
                        if (coneDist > 0) {
                            mapDevices.forEach(d => {
                                var t = getUiType(d);
                                if (t !== 'cctv') return;
                                var mc = d.map_coordinates;
                                if (!mc || mc.x == null || mc.y == null || mc.camera_rotation == null || mc.camera_angle == null) return;
                                var x = parseFloat(mc.x); var y = parseFloat(mc.y);
                                if (isNaN(x) || isNaN(y)) return;
                                var rot = Number(mc.camera_rotation) * Math.PI / 180;
                                var half = (Number(mc.camera_angle) || 60) * 0.5 * Math.PI / 180;
                                var dist = (mc.camera_range != null && !isNaN(Number(mc.camera_range))) ? Number(mc.camera_range) : coneDist;
                                var pts = [[y, x]];
                                for (var seg = 0; seg <= 20; seg++) {
                                    var ang = rot - half + (2 * half * seg / 20);
                                    pts.push([y - dist * Math.sin(ang), x + dist * Math.cos(ang)]);
                                }
                                var poly = L.polygon(pts, {
                                    color: d.status === 'online' ? 'rgba(0,210,106,0.5)' : d.status === 'amber' ? 'rgba(255,193,7,0.5)' : 'rgba(248,49,47,0.5)',
                                    fillColor: d.status === 'online' ? '#00d26a' : d.status === 'amber' ? '#ffc107' : '#f8312f',
                                    fillOpacity: 0.25, weight: 2
                                });
                                poly.on('click', function() { openDeviceModal(d.ip); });
                                poly.bindTooltip((d.name || d.ip || 'Camera').replace(/</g,'&lt;') + ' (' + (mc.camera_rotation||0) + '¬∞ / ' + (mc.camera_angle||60) + '¬∞)', { permanent: false, direction: 'top', className: 'device-marker-tooltip' });
                                poly.addTo(cameraConesLayer);
                            });
                        }
                    }
                } catch (e) { /* cones optional */ }
            }
            // 3c. WAP coverage circles (when toggle on)
            if (mapWapCoverageVisible) {
                try {
                    var b = map.getBounds();
                    if (b && b.getNorthEast && b.getSouthWest) {
                        var mapH = b.getNorthEast().lat - b.getSouthWest().lat;
                        var mapW = b.getNorthEast().lng - b.getSouthWest().lng;
                        var coneDist = Math.min(mapH, mapW) * 0.08;
                        if (coneDist > 0) {
                            mapDevices.forEach(d => {
                                var t = getUiType(d);
                                if (t !== 'wap' && t !== 'wifi' && t !== 'ap') return;
                                var mc = d.map_coordinates;
                                if (!mc || mc.x == null || mc.y == null) return;
                                var x = parseFloat(mc.x); var y = parseFloat(mc.y);
                                if (isNaN(x) || isNaN(y)) return;
                                var markerSize = 30;
                                var circleRadius = Math.round(markerSize * 2.5);
                                var circle = L.circleMarker([y, x], {
                                    radius: circleRadius,
                                    interactive: false,
                                    color: d.status === 'online' ? 'rgba(0,210,106,0.5)' : d.status === 'amber' ? 'rgba(255,193,7,0.5)' : 'rgba(248,49,47,0.5)',
                                    fillColor: d.status === 'online' ? '#00d26a' : d.status === 'amber' ? '#ffc107' : '#f8312f',
                                    fillOpacity: 0.2, weight: 2
                                });
                                circle.addTo(cameraConesLayer);
                            });
                        }
                    }
                } catch (e) { /* wap coverage optional */ }
            }

            // 4. Device name labels: black text on white, fixed pixel offset from marker (tracks close when zooming), centred text.
            if (mapLabelsVisible) {
                const LABEL_OFFSET_PX = 12; // pixels above marker (stays consistent at any zoom)
                const keyToDevices = new Map();
                mapDevices.forEach(d => {
                    let x, y;
                    if (d.map_coordinates && typeof d.map_coordinates === 'object') { x = parseFloat(d.map_coordinates.x); y = parseFloat(d.map_coordinates.y); }
                    else { x = parseFloat(d.x); y = parseFloat(d.y); }
                    const key = `${Math.round(x / LABEL_GRID)}_${Math.round(y / LABEL_GRID)}`;
                    const cluster = positionClusters.get(key);
                    if (cluster && cluster.sameType && cluster.devices.length > 1) return; // already have group label
                    if (!keyToDevices.has(key)) keyToDevices.set(key, []);
                    keyToDevices.get(key).push({ d, x, y });
                });
                keyToDevices.forEach((arr) => {
                    const n = arr.length;
                    arr.forEach((item, idx) => {
                        const d = item.d, x = item.x, y = item.y;
                        const name = (d.name || d.ip || 'Device').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
                        const ip = (d.ip || '').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
                        let labelLat, labelLng;
                        const pt = map.latLngToContainerPoint([y, x]);
                        if (n === 1) {
                            const labelPt = L.point(pt.x, pt.y - LABEL_OFFSET_PX);
                            const latLng = map.containerPointToLatLng(labelPt);
                            labelLat = latLng.lat; labelLng = latLng.lng;
                        } else {
                            const angleDeg = 90 + (idx / n) * 360;
                            const angleRad = angleDeg * Math.PI / 180;
                            const labelPt = L.point(pt.x + LABEL_OFFSET_PX * 1.2 * Math.cos(angleRad), pt.y - LABEL_OFFSET_PX * 1.2 * Math.sin(angleRad));
                            const latLng = map.containerPointToLatLng(labelPt);
                            labelLat = latLng.lat; labelLng = latLng.lng;
                        }
                        const labelHtml = '<span class="device-map-label-name" style="color:#000!important;background:#fff!important;">' + name + '</span>' + (ip ? '<span class="device-map-label-ip">' + ip + '</span>' : '');
                        const icon = L.divIcon({
                            className: 'device-map-label',
                            html: labelHtml,
                            iconSize: [90, 22],
                            iconAnchor: [45, 22]
                        });
                        const labelMarker = L.marker([labelLat, labelLng], { icon: icon, pane: 'labelsPane' });
                        labelMarker.addTo(deviceLabelsLayer);
                    });
                });
            }
        }
        map.on('zoomend', function() { if (mapLabelsVisible || mapCctvCoverageVisible || mapWapCoverageVisible) plotDevicesOnMap(); });
        function togglePause(){ isPaused=!isPaused; const btn=document.getElementById('pause-btn'); if(btn) btn.innerText=isPaused?"‚ñ∂":"‚è∏"; if(!isPaused) updateDashboard(); }
        setInterval(()=>{if(!isPaused)nextMap();},15000);

        // === HISTORY & ACKNOWLEDGED ISSUES ===
        let acknowledgedIssues = [];
        async function loadAcknowledgedIssues() {
            try {
                const base = isCloudMode ? CLOUD_URL : '';
                const r = await fetch(base + '/api/acknowledged-issues?active=1');
                if (r.ok) acknowledgedIssues = await r.json();
                if (!Array.isArray(acknowledgedIssues)) acknowledgedIssues = [];
            } catch (e) { acknowledgedIssues = []; }
        }
        async function loadMonitorSettings() {
            try {
                const base = isCloudMode ? CLOUD_URL : '';
                const r = await fetch(base + '/api/monitor-settings');
                if (r.ok) cachedMonitorSettings = await r.json();
                if (!cachedMonitorSettings.deviceConnectionTemplate) cachedMonitorSettings.deviceConnectionTemplate = 'http://{{ip}}';
            } catch (e) { cachedMonitorSettings = { deviceConnectionTemplate: 'http://{{ip}}' }; }
        }
        async function loadDeviceNotes() {
            try {
                const base = isCloudMode ? CLOUD_URL : '';
                const r = await fetch(base + '/api/device-notes');
                if (r.ok) cachedDeviceNotes = await r.json();
                if (typeof cachedDeviceNotes !== 'object') cachedDeviceNotes = {};
            } catch (e) { cachedDeviceNotes = {}; }
        }
        async function loadDeviceLoginUrls() {
            try {
                const base = isCloudMode ? CLOUD_URL : '';
                const r = await fetch(base + '/api/device-login-urls');
                if (r.ok) cachedDeviceLoginUrls = await r.json();
                if (typeof cachedDeviceLoginUrls !== 'object') cachedDeviceLoginUrls = {};
            } catch (e) { cachedDeviceLoginUrls = {}; }
        }
        async function loadHistoryPanel() {
            const base = isCloudMode ? CLOUD_URL : '';
            const periods = [{ key: '24h', id: 'h-24h' }, { key: '7d', id: 'h-7d' }, { key: '30d', id: 'h-30d' }];
            const noteEl = document.getElementById('history-ack-note');
            let maxAck = 0;
            const results = await Promise.all(periods.map(p => fetch(`${base}/api/history/summary?period=${p.key}`).then(r => r.ok ? r.json() : null).catch(() => null)));
            const unacks = results.map((data, i) => ({ unack: (data && (data.unacknowledgedProblemCount || 0)), ack: (data && (data.acknowledgedProblemCount || 0)) }));
            unacks.forEach((u, i) => { if (u.ack > maxAck) maxAck = u.ack; });
            results.forEach((data, i) => {
                const el = document.getElementById(periods[i].id);
                if (!el) return;
                if (!data) { el.textContent = '‚Äî'; el.className = 'history-period'; return; }
                const unack = data.unacknowledgedProblemCount || 0;
                if (unack === 0) {
                    el.textContent = '‚úì No problematic fails';
                    el.className = 'history-ok';
                } else {
                    el.textContent = `${unack} unacknowledged issue(s)`;
                    el.className = 'history-fails';
                }
            });
            // Show only the most relevant period(s): 30d always; 7d only if 30d has issues; 24h only if 24h has issues
            const u24 = unacks[0].unack, u7 = unacks[1].unack, u30 = unacks[2].unack;
            const row24 = document.getElementById('h-24h') && document.getElementById('h-24h').closest('.history-row');
            const row7 = document.getElementById('h-7d') && document.getElementById('h-7d').closest('.history-row');
            const row30 = document.getElementById('h-30d') && document.getElementById('h-30d').closest('.history-row');
            if (row24) row24.style.display = u24 > 0 ? '' : 'none';
            if (row7) row7.style.display = (u7 > 0 || u30 > 0) ? '' : 'none';
            if (row30) row30.style.display = '';
            if (noteEl) noteEl.textContent = maxAck > 0 ? `${maxAck} known/acknowledged issue(s) excluded from count` : '';
        }

        let historyModalPeriod = '24h';
        function openHistoryModal(period) {
            historyModalPeriod = period || historyModalPeriod;
            document.getElementById('history-modal').style.display = 'flex';
            document.getElementById('history-modal').classList.add('active');
            document.querySelectorAll('#history-modal .control-btn').forEach(b => { b.classList.remove('expanded-active'); });
            const btn = document.getElementById('hist-btn-' + historyModalPeriod);
            if (btn) btn.classList.add('expanded-active');
            renderHistoryDetail();
        }
        function closeHistoryModal() {
            document.getElementById('history-modal').classList.remove('active');
            document.getElementById('history-modal').style.display = 'none';
        }
        function setHistoryPeriod(period) {
            historyModalPeriod = period;
            document.querySelectorAll('#history-modal .control-btn').forEach(b => { b.classList.remove('expanded-active'); });
            const btn = document.getElementById('hist-btn-' + period);
            if (btn) btn.classList.add('expanded-active');
            renderHistoryDetail();
        }
        document.getElementById('history-modal')?.addEventListener('click', e => { if (e.target.id === 'history-modal') closeHistoryModal(); });

        let historyUnackEnriched = [];
        let historyFilterType = '';
        let historyFilterOfflineMin = 0;
        let historyFilterSite = '';
        let lastHistoryData = null;

        function applyHistoryFilters() {
            return historyUnackEnriched.filter(d => {
                if (historyFilterType && (d.type || '').toLowerCase() !== historyFilterType.toLowerCase()) return false;
                if (historyFilterOfflineMin > 0 && (d.offline || 0) < historyFilterOfflineMin) return false;
                if (historyFilterSite === 'T') {
                    const fid = (d.floor_id || '').toUpperCase();
                    if (!fid.startsWith('T-')) return false;
                } else if (historyFilterSite === 'K') {
                    const fid = (d.floor_id || '').toUpperCase();
                    if (!fid.startsWith('K-')) return false;
                }
                return true;
            });
        }

        function buildHistoryBodyHtml(data) {
            const filtered = applyHistoryFilters();
            const typesInList = [...new Set(historyUnackEnriched.map(d => (d.type || '').toLowerCase()).filter(Boolean))].sort();
            let html = '';
            html += `<div style="margin-bottom:16px; font-size:13px; color:#aaa;">Since ${new Date(data.since).toLocaleString()}</div>`;
            html += `<div style="margin-bottom:12px;"><span style="color:#888;">Total checks:</span> <strong>${data.totalChecks || 0}</strong></div>`;
            if (historyUnackEnriched.length > 0) {
                html += `<div class="dd-section" style="margin-top:16px;">Unacknowledged problems</div>`;
                if (!isCloudMode) {
                    html += `<div style="display:flex; flex-wrap:wrap; align-items:center; gap:10px 16px; margin-bottom:12px;">`;
                    html += `<label style="color:#888; font-size:12px;">Device type:</label><select id="history-filter-type" onchange="setHistoryFilterType(this.value); renderHistoryDetailBody();" style="background:#333; color:#fff; border:1px solid #444; padding:6px 10px; border-radius:6px; font-size:12px;"><option value="">All</option>${typesInList.map(t => `<option value="${t}" ${historyFilterType === t ? 'selected' : ''}>${t}</option>`).join('')}</select>`;
                    html += `<label style="color:#888; font-size:12px;">Offline count:</label><select id="history-filter-offline" onchange="setHistoryFilterOffline(parseInt(this.value,10)); renderHistoryDetailBody();" style="background:#333; color:#fff; border:1px solid #444; padding:6px 10px; border-radius:6px; font-size:12px;"><option value="0">Any</option><option value="1" ${historyFilterOfflineMin===1?'selected':''}>1+</option><option value="5" ${historyFilterOfflineMin===5?'selected':''}>5+</option><option value="10" ${historyFilterOfflineMin===10?'selected':''}>10+</option><option value="20" ${historyFilterOfflineMin===20?'selected':''}>20+</option></select>`;
                    html += `<label style="color:#888; font-size:12px;">Site:</label><select id="history-filter-site" onchange="setHistoryFilterSite(this.value); renderHistoryDetailBody();" style="background:#333; color:#fff; border:1px solid #444; padding:6px 10px; border-radius:6px; font-size:12px;"><option value="">All</option><option value="T" ${historyFilterSite==='T'?'selected':''}>T site</option><option value="K" ${historyFilterSite==='K'?'selected':''}>K site</option></select>`;
                    html += `<button class="control-btn" onclick="historySelectAll()">Select all</button><button class="control-btn" onclick="historySelectNone()">Select none</button>`;
                    html += `<span id="history-ack-selected-wrap" style="display:none;"><button class="control-btn" id="history-ack-selected-btn" onclick="acknowledgeSelectedFromHistory()">Acknowledge selected</button></span>`;
                    html += `<span style="color:#888; font-size:12px;">Showing ${filtered.length} of ${historyUnackEnriched.length}</span>`;
                    html += `</div>`;
                    html += `<div id="history-ack-duration-bar" style="display:none; margin-bottom:12px; padding:10px; background:#252525; border-radius:8px; border:1px solid #333;"><span style="color:#aaa; font-size:12px;">Acknowledge for:</span> <button class="control-btn" style="margin-left:6px;" onclick="confirmHistoryAck('until_next_issue')" title="Clear from history while device is online; will show again if it goes offline">Clear until next problem</button><button class="control-btn" style="margin-left:4px;" onclick="confirmHistoryAck('1h')">1 hour</button><button class="control-btn" style="margin-left:4px;" onclick="confirmHistoryAck('1d')">1 day</button><button class="control-btn" style="margin-left:4px;" onclick="confirmHistoryAck('until_online')">Until online</button><button class="control-btn" style="margin-left:4px;" onclick="confirmHistoryAck('forever')">Forever</button><button class="control-btn" style="margin-left:8px; color:#888;" onclick="cancelHistoryAck()">Cancel</button></div>`;
                }
                filtered.forEach(d => {
                    const ipEsc = (d.ip || '').replace(/'/g, "\\'").replace(/"/g, '&quot;');
                    const ipAttr = (d.ip || '').replace(/"/g, '&quot;');
                    const typeLabel = (d.type || '‚Äî');
                    const siteLabel = (d.floor_id || '').startsWith('T-') ? 'T' : (d.floor_id || '').startsWith('K-') ? 'K' : '‚Äî';
                    if (isCloudMode) {
                        html += `<div style="padding:10px; border:1px solid #333; border-radius:6px; margin-bottom:6px;"><div style="cursor:pointer;" onclick="closeHistoryModal(); openDeviceModal('${ipEsc}')"><span style="font-weight:600;">${d.name || d.ip}</span> <span style="color:#888; font-family:monospace;">${d.ip}</span> <span style="color:#f8312f;">offline: ${d.offline || 0} amber: ${d.amber || 0}</span></div><div style="font-size:11px; color:#666; margin-top:4px;">Edits disabled in cloud view.</div></div>`;
                    } else {
                        html += `<div class="history-unack-row" style="display:flex; align-items:center; gap:10px; padding:10px; border:1px solid #333; border-radius:6px; margin-bottom:6px;"><input type="checkbox" class="history-ack-check" data-ip="${ipAttr}" onchange="updateHistoryAckSelectedBtn()"><div style="cursor:pointer; flex:1; min-width:0;" onclick="closeHistoryModal(); openDeviceModal('${ipEsc}')"><span style="font-weight:600;">${(d.name || d.ip).replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span> <span style="color:#888; font-family:monospace;">${d.ip}</span> <span style="color:#888; font-size:11px;">${typeLabel}</span> <span style="color:#666; font-size:11px;">${siteLabel}</span> <span style="color:#f8312f;">offline: ${d.offline || 0} amber: ${d.amber || 0}</span></div><button class="control-btn history-ack-one-btn" style="flex-shrink:0;" data-ip="${ipAttr}" onclick="event.stopPropagation(); showHistoryAckDurationForIps([this.getAttribute('data-ip')])">Acknowledge</button></div>`;
                    }
                });
            } else {
                html += `<div style="color:#00d26a; margin-top:12px;">‚úì No unacknowledged problematic fails in this period.</div>`;
            }
            if (data.acknowledgedProblemCount > 0) {
                html += `<div class="dd-section" style="margin-top:16px;">Acknowledged / known issues (${data.devicesWithAcknowledgedProblems?.length || 0})</div>`;
                (data.devicesWithAcknowledgedProblems || []).forEach(d => {
                    html += `<div style="padding:8px; border-bottom:1px solid #2a2a2a; font-size:13px;"><span style="font-weight:600;">${d.name || d.ip}</span> <span style="color:#666; font-family:monospace;">${d.ip}</span></div>`;
                });
            }
            return html;
        }

        async function renderHistoryDetail() {
            const body = document.getElementById('history-detail-body');
            if (!body) return;
            body.innerHTML = '<div style="color:#888;">Loading...</div>';
            const base = isCloudMode ? CLOUD_URL : '';
            try {
                const r = await fetch(`${base}/api/history/summary?period=${historyModalPeriod}`);
                if (!r.ok) { body.innerHTML = '<div style="color:#f8312f;">Failed to load history.</div>'; return; }
                const data = await r.json();
                lastHistoryData = { since: data.since, totalChecks: data.totalChecks, acknowledgedProblemCount: data.acknowledgedProblemCount, devicesWithAcknowledgedProblems: data.devicesWithAcknowledgedProblems || [] };
                const rawUnack = data.devicesWithUnacknowledgedProblems || [];
                historyUnackEnriched = rawUnack.map(d => {
                    const dev = cachedDevices.find(c => (c.ip || '').trim() === (d.ip || '').trim());
                    return { ...d, type: dev ? (dev.type || '') : '', floor_id: dev ? (dev.floor_id || '') : '' };
                });
                body.innerHTML = buildHistoryBodyHtml(lastHistoryData);
            } catch (e) {
                body.innerHTML = '<div style="color:#f8312f;">Error: ' + (e.message || 'Failed to load') + '</div>';
            }
        }

        function setHistoryFilterType(v) { historyFilterType = v || ''; }
        function setHistoryFilterOffline(v) { historyFilterOfflineMin = v || 0; }
        function setHistoryFilterSite(v) { historyFilterSite = v || ''; }

        function renderHistoryDetailBody() {
            const body = document.getElementById('history-detail-body');
            if (!body || !lastHistoryData) return;
            body.innerHTML = buildHistoryBodyHtml(lastHistoryData);
        }

        function historySelectAll() {
            document.querySelectorAll('.history-ack-check').forEach(cb => { cb.checked = true; });
            updateHistoryAckSelectedBtn();
        }
        function historySelectNone() {
            document.querySelectorAll('.history-ack-check').forEach(cb => { cb.checked = false; });
            updateHistoryAckSelectedBtn();
        }

        // === SINGLE SOURCE OF TRUTH: device status (DB + drive/toner overrides) ===
        function getEffectiveStatus(d) {
            if (!d) return 'offline';
            let st = (d.status === 'online' ? 'online' : (d.status === 'amber' ? 'amber' : 'offline'));
            const t = getUiType(d);
            const det = safeParseDetails(d.details);
            const ackIps = new Set((acknowledgedIssues || []).map(a => (a.ip || a.deviceIp || '').trim()).filter(Boolean));
            if (t === 'nvr' || t === 'hardware') {
                const note = (det && det.note) ? String(det.note) : '';
                const hasError = /Disk\s*\d+\s*(FAIL|Offline|Abnormal|SmartFailed)/i.test(note);
                let totalDrives = parseInt(det.diskCount, 10) || 0;
                if (totalDrives <= 0) {
                    const dm = note.match(/(\d+)\s*Drives?/i) || note.match(/Cap:\s*[\d.]+\s*TB\s*\|\s*(\d+)/i);
                    if (dm) totalDrives = parseInt(dm[1], 10) || 0;
                }
                const diskNums = (note.match(/Disk\s*(\d+)/gi) || []).map(m => parseInt((m.match(/\d+/) || [0])[0], 10)).filter(n => n > 0);
                if (totalDrives <= 0 && diskNums.length > 0) totalDrives = Math.max(...diskNums);
                totalDrives = Math.max(totalDrives, 1);
                const statusByDrive = parseDriveStatusByNumber(note, totalDrives);
                const hasWarning = Object.values(statusByDrive).some(v => v === 'warning') || /drive\(s\)\s*missing|missing\s*drive/i.test(note);
                if (!ackIps.has((d.ip || '').trim())) { if (hasError) st = 'offline'; else if (hasWarning) st = 'amber'; }
            }
            if (st === 'online' && deviceHasDriveWarning(d)) st = 'amber';
            return st;
        }

        // === CAMERA ‚Üí NVR LINKING (by number: Camera 1 ‚Üî NVR 1; Camera 10 ‚Üî NVR 10 when exact; else digit fallback) ===
        function getLeadingNumberFromName(name) {
            if (!name || typeof name !== 'string') return null;
            const m = String(name).trim().match(/^[^0-9]*([1-9]\d*)/);
            return m ? parseInt(m[1], 10) : null;
        }
        function getLeadingDigitFromName(name) {
            if (!name || typeof name !== 'string') return null;
            const m = String(name).trim().match(/^[^0-9]*([1-9])/);
            return m ? parseInt(m[1], 10) : null;
        }
        function getNvrNumberFromName(name) {
            if (!name || typeof name !== 'string') return null;
            const m = String(name).trim().match(/nvr\s*[-]?\s*(\d+)/i);
            return m ? parseInt(m[1], 10) : null;
        }
        function getNvrDigitFromName(name) {
            if (!name || typeof name !== 'string') return null;
            const m = String(name).trim().match(/nvr\s*[-]?\s*(\d)/i);
            return m ? parseInt(m[1], 10) : null;
        }
        function findNvrForCamera(cameraName) {
            if (!cachedDevices.length) return null;
            const nvrList = cachedDevices.filter(d => getUiType(d) === 'nvr');
            if (nvrList.length === 0) return null;
            const num = getLeadingNumberFromName(cameraName);
            const digit = getLeadingDigitFromName(cameraName);
            const match = nvrList.find(d => {
                const nvrNum = getNvrNumberFromName(d.name);
                const nvrDigit = getNvrDigitFromName(d.name);
                if (num != null && nvrNum != null && nvrNum === num) return true;
                if (digit != null && nvrDigit != null && nvrDigit === digit) return true;
                if (digit != null && nvrNum != null && nvrNum === digit) return true;
                return false;
            });
            if (match) return match;
            if (nvrList.length === 1) return nvrList[0];
            return null;
        }
        function getCamerasOnNvr(nvrDevice) {
            if (!nvrDevice || !cachedDevices.length) return [];
            const nvrNum = getNvrNumberFromName(nvrDevice.name);
            const nvrDigit = getNvrDigitFromName(nvrDevice.name);
            if (nvrNum == null && nvrDigit == null) return [];
            return cachedDevices.filter(d => {
                if (getUiType(d) !== 'cctv') return false;
                const camNum = getLeadingNumberFromName(d.name);
                const camDigit = getLeadingDigitFromName(d.name);
                if (nvrNum != null && camNum != null && camNum === nvrNum) return true;
                if (nvrDigit != null && camDigit != null && camDigit === nvrDigit) return true;
                if (nvrNum != null && camDigit != null && camDigit === nvrNum) return true;
                return false;
            });
        }
        function exportNvrCamerasCsv(nvrName, cameras) {
            if (!cameras || cameras.length === 0) return;
            const header = 'Name,IP,Status,Last Seen\n';
            const rows = cameras.map(c => {
                const n = (c.name || '').replace(/"/g, '""');
                const i = (c.ip || '').replace(/"/g, '""');
                const s = (c.status || '').replace(/"/g, '""');
                const t = c.updatedAt ? new Date(c.updatedAt).toLocaleString() : '';
                return `"${n}","${i}","${s}","${t}"`;
            }).join('\n');
            const csv = '\uFEFF' + header + rows;
            const link = document.createElement('a');
            link.href = 'data:text/csv;charset=utf-8,' + encodeURIComponent(csv);
            link.download = (nvrName || 'NVR').replace(/[^a-zA-Z0-9-_]/g, '_') + '_cameras_' + new Date().toISOString().slice(0,10) + '.csv';
            link.click();
        }

        // === MODALS ===
        let currentModalType=null, cachedDevices=[], currentSort={col:'status',dir:1};
        let lastDevicesSig='', pollCount=0;
        let cachedMonitorSettings = { deviceConnectionTemplate: 'http://{{ip}}' };
        let cachedDeviceNotes = {};
        let cachedDeviceLoginUrls = {};
        let currentDeviceIpForNote = null;

        // Normalize so we never duplicate http/https (e.g. http://https//host -> https://host)
        function normalizeConnectionUrl(value) {
            if (!value || typeof value !== 'string') return '';
            const s = value.trim();
            if (!s) return '';
            const lower = s.toLowerCase();
            if (lower.startsWith('https://')) return s;
            if (lower.startsWith('http://')) return s;
            if (lower.startsWith('https//')) return 'https://' + s.slice(7);
            if (lower.startsWith('http//')) return 'http://' + s.slice(6);
            return s; // hostname or IP, no scheme
        }
        function buildConnectionUrl(d, template, perDeviceLoginUrl) {
            if (perDeviceLoginUrl && String(perDeviceLoginUrl).trim()) {
                const u = normalizeConnectionUrl(perDeviceLoginUrl);
                if (u) return u.startsWith('http') ? u : 'http://' + u;
            }
            const ip = (d.ip || '').trim();
            const name = (d.name || '').trim();
            if (!ip && !name) return '';
            const raw = ip || name;
            const alreadyUrl = /^https?:\/\//i.test(raw) || /^https?\/\//i.test(raw);
            if (alreadyUrl) {
                const u = normalizeConnectionUrl(raw);
                return u.startsWith('http') ? u : 'http://' + u;
            }
            const built = (template || 'http://{{ip}}').replace(/\{\{ip\}\}/gi, ip).replace(/\{\{name\}\}/gi, name).trim();
            const u = normalizeConnectionUrl(built);
            return u.startsWith('http') ? u : 'http://' + u;
        }
        function openModal(t){ 
            currentModalType=t; 
            document.getElementById('modal-search').value=''; 
            document.getElementById('modal-overlay').classList.add('active'); 
            const tl={'service':'Cloud Services','server':'Local Servers','nvr':'NVRs','esxi':'ESXi Hosts','printer':'Printers','cctv':'CCTV','switch':'Switches','wap':'WAPs','telephone':'Phones','access_control':'Access','hardware':'Hardware','firewall':'Firewall'}; 
            document.getElementById('modal-title').innerText=tl[t]||t.toUpperCase(); 
            renderModalContent(); 
        }
        function closeModal(){ document.getElementById('modal-overlay').classList.remove('active'); currentModalType=null; }
        document.getElementById('modal-overlay').addEventListener('click',e=>{if(e.target.id==='modal-overlay')closeModal();});
        
        // --- DEVICE POP-OUT LOGIC (UPDATED WITH DRIVE VIZ) ---
        // True if device is storage type and has any drive in warning state (DEGRADED, Rebuild, etc.)
        function deviceHasDriveWarning(d) {
            const t = getUiType(d);
            if (!['nvr','hardware','san','nas'].includes(t)) return false;
            const det = safeParseDetails(d.details);
            const note = (det && det.note) ? String(det.note) : '';
            if (!note || !/Disk\s*\d+/i.test(note)) return false;
            let totalDrives = parseInt(det.diskCount, 10) || 0;
            if (totalDrives <= 0) {
                const m = note.match(/(\d+)\s*Drives?/i) || note.match(/Cap:\s*[\d.]+\s*TB\s*\|\s*(\d+)/i);
                if (m) totalDrives = parseInt(m[1], 10) || 0;
            }
            const diskNums = (note.match(/Disk\s*(\d+)/gi) || []).map(s => parseInt(s.match(/\d+/)?.[0], 10)).filter(n => n > 0);
            if (totalDrives <= 0 && diskNums.length > 0) totalDrives = Math.max(...diskNums);
            if (totalDrives <= 0) return false;
            const statusByDrive = parseDriveStatusByNumber(note, totalDrives);
            return Object.values(statusByDrive).some(v => v === 'warning');
        }
        // Parse note into per-drive status: driveStatus[driveNum] = 'ok'|'warning'|'error'. Drive numbers 1-based.
        function parseDriveStatusByNumber(note, totalDrives) {
            const statusByDrive = {};
            for (let i = 1; i <= totalDrives; i++) statusByDrive[i] = 'ok';
            if (!note || typeof note !== 'string') return statusByDrive;
            const n = note;
            // "Disk 3 FAIL", "Disk 2 Offline", "Disk 1 Abnormal", "Disk 4 SmartFailed"
            (n.match(/Disk\s*(\d+)\s*(?:FAIL|Offline|Abnormal|SmartFailed|Bad|Error)/gi) || []).forEach(s => {
                const num = parseInt(s.match(/Disk\s*(\d+)/i)?.[1], 10);
                if (num >= 1) statusByDrive[num] = 'error';
            });
            (n.match(/Disk\s*(\d+)\s*:\s*(?:FAIL|Offline|Abnormal|SmartFailed|Bad|Error)/gi) || []).forEach(s => {
                const num = parseInt(s.match(/Disk\s*(\d+)/i)?.[1], 10);
                if (num >= 1) statusByDrive[num] = 'error';
            });
            // "Disk 3 Rebuilding", "Disk 2 Initializing", "Disk 1 Unformatted", "Disk 4: Rebuild"
            (n.match(/Disk\s*(\d+)[:\s]*(?:Warning|Unformatted|Warn|DEGRADED|Rebuild|Rebuilding|Initializing|Smart|Status\()/gi) || []).forEach(s => {
                const num = parseInt(s.match(/Disk\s*(\d+)/i)?.[1], 10);
                if (num >= 1 && statusByDrive[num] !== 'error') statusByDrive[num] = 'warning';
            });
            return statusByDrive;
        }
        // Only for storage devices (nvr, hardware/SAN/NAS). Renders one block per drive; missing drives (expected > actual) as red blocks.
        function generateDriveBarHtml(note, deviceType, details) {
            if (!note) return '';
            const t = (deviceType || '').toLowerCase();
            const isStorage = t === 'nvr' || t === 'hardware' || t === 'san' || t === 'nas' || (t === 'server' && (note.includes('Cap:') || note.includes('Drives') || note.includes('RAID')));
            const hasDriveInfo = note.includes('Cap:') || note.includes('Drives') || note.includes('RAID') || note.includes('Disk ') || note.includes('All drives OK');
            if (!isStorage || !hasDriveInfo) return '';

            let totalDrives = 0;
            if (details && (details.diskCount != null && details.diskCount !== '')) totalDrives = parseInt(details.diskCount, 10) || 0;
            if (totalDrives <= 0) {
                const drivesMatch = note.match(/(\d+)\s*Drives?/i) || note.match(/Cap:\s*[\d.]+\s*TB\s*\|\s*(\d+)/i);
                if (drivesMatch) totalDrives = parseInt(drivesMatch[1], 10) || 0;
            }
            const diskMatches = note.match(/Disk\s*(\d+)/gi) || [];
            const diskNumbers = diskMatches.map(m => { const n = m.match(/\d+/); return n ? parseInt(n[0], 10) : 0; }).filter(n => n > 0);
            const maxDiskNum = diskNumbers.length > 0 ? Math.max(...diskNumbers) : 0;
            if (totalDrives <= 0 && maxDiskNum > 0) totalDrives = maxDiskNum;
            totalDrives = Math.max(totalDrives, maxDiskNum, 1);

            let expectedDrives = totalDrives;
            const expectedMatch = note.match(/expected\s+(\d+)/i);
            if (expectedMatch) expectedDrives = Math.max(parseInt(expectedMatch[1], 10) || totalDrives, totalDrives);

            const statusByDrive = parseDriveStatusByNumber(note, totalDrives);
            const segmentWidth = 100 / expectedDrives;
            let barSegments = '';
            for (let i = 1; i <= expectedDrives; i++) {
                const st = i <= totalDrives ? (statusByDrive[i] || 'ok') : 'error';
                const color = st === 'error' ? '#f8312f' : (st === 'warning' ? '#ffc107' : '#00d26a');
                const title = i <= totalDrives ? `Drive ${i}: ${st}` : `Drive ${i}: missing`;
                barSegments += `<div class="drive-block" style="width:${segmentWidth}%;background:${color};" title="${title}"></div>`;
            }
            const bayLabel = expectedDrives > totalDrives ? `${totalDrives} of ${expectedDrives} BAY` : `${expectedDrives} BAY`;
            return `<div style="margin-top:10px; margin-bottom:5px;">
                        <div style="font-size:10px; color:#888; margin-bottom:2px; font-weight:bold;">DRIVE STATUS (${bayLabel})</div>
                        <div style="width:100%; height:12px; background:#222; border-radius:2px; display:flex; overflow:hidden;">${barSegments}</div>
                    </div>`;
        }

        function openDeviceModal(ip) {
            closeModal();
            const d = cachedDevices.find(dev => dev.ip === ip);
            if (!d) return;
            currentDeviceIpForNote = d.ip || null;

            const pop = document.getElementById('device-detail-modal');
            pop.style.display = 'flex'; // Ensure visible first
            setTimeout(()=> pop.classList.add('active'), 10); // Then fade in

            const icon = getDeviceIcon(d.type, '1.1em');
            document.getElementById('dd-name').innerHTML = (icon ? icon + ' ' : '') + (d.name || 'Device').replace(/</g,'&lt;').replace(/>/g,'&gt;');
            document.getElementById('dd-sub').innerText = `${(d.type||'DEVICE').toUpperCase()} ‚Ä¢ ${d.ip||'No IP'}`;

            const cont = document.getElementById('dd-content');
            const det = safeParseDetails(d.details);
            const template = (cachedMonitorSettings.deviceConnectionTemplate || 'http://{{ip}}').trim();
            const perDeviceLogin = cachedDeviceLoginUrls[d.ip];
            const connectionUrl = buildConnectionUrl(d, template, perDeviceLogin);

            let effectiveStatus = (d.status === 'online' && deviceHasDriveWarning(d)) ? 'amber' : d.status;
            const uiType = getUiType(d);
            const isCamera = uiType === 'cctv' || (d.type && (d.type.toLowerCase() === 'cctv' || d.type.toLowerCase() === 'camera'));
            const nvrDevice = isCamera ? findNvrForCamera(d.name) : null;
            const nvrEffectiveStatus = nvrDevice ? getEffectiveStatus(nvrDevice) : 'online';
            // If camera is online but its linked NVR is offline, show as amber (can't record). Amber NVR = attention needed but still recording.
            if (isCamera && nvrDevice && nvrEffectiveStatus === 'offline' && effectiveStatus === 'online') effectiveStatus = 'amber';
            let stColor = effectiveStatus === 'online' ? '#00d26a' : (effectiveStatus === 'amber' ? '#ffc107' : '#f8312f');
            const lastOnlineStr = d.status === 'online' && d.last_seen
                ? new Date(d.last_seen).toLocaleString()
                : (d.lastOnlineAt ? new Date(d.lastOnlineAt).toLocaleString() : '‚Äî');
            const lastIssueStr = d.last_issue ? new Date(d.last_issue).toLocaleString() : null;
            const isFirewall = uiType === 'firewall';
            let displayDet = isCamera ? getCameraDisplayDetails(det) : (isFirewall ? (() => { const o = { ...det }; delete o.Up; if (o.uptime === '0d') delete o.uptime; return o; })() : det);
            if (isCamera && d.status === 'offline') displayDet = { ...displayDet, note: 'Offline' };
            if (isCamera && d.status === 'online' && d.upSince) {
                const u = (displayDet.uptime || '').trim();
                if (u === '?' || u === '1m' || u === '<1m') displayDet = { ...displayDet, uptime: formatSeenFor(d.upSince) };
            }

            const connectHref = connectionUrl ? connectionUrl.replace(/"/g,'&quot;') : '#';
            const nvrRow = (isCamera && nvrDevice) ? `<div class="dd-row"><span class="dd-label">NVR</span><span class="dd-value"><a href="#" onclick="event.preventDefault(); document.getElementById('device-detail-modal').classList.remove('active'); document.getElementById('device-detail-modal').style.display='none'; openDeviceModal('${(nvrDevice.ip||'').replace(/'/g,"\\'")}'); return false;" style="color:#4a9eff;">${String(nvrDevice.name||'NVR').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</a></span></div>` : '';
            const canLocate = deviceIsLocatable(d);
            const locateRow = canLocate ? `<div class="dd-row"><span class="dd-label">Map</span><span class="dd-value"><button type="button" class="control-btn" onclick="locateDeviceOnMap('${(d.ip||'').replace(/'/g,"\\'")}')">Locate</button></span></div>` : '';
            const statusSuffix = (isCamera && nvrDevice && nvrEffectiveStatus === 'offline' && d.status === 'online') ? ' <span style="color:#888;font-weight:normal;">(NVR offline ‚Äî not recording)</span>' : '';
            const isNvr = uiType === 'nvr';
            const nvrCameras = isNvr ? getCamerasOnNvr(d) : [];
            const nvrCamerasSection = isNvr ? (() => {
                const camRows = nvrCameras.map(cam => {
                    const camNvr = findNvrForCamera(cam.name);
                    const camNvrSt = camNvr ? getEffectiveStatus(camNvr) : 'online';
                    const camSt = (cam.status === 'online') ? (camNvrSt === 'offline' ? 'amber' : 'online') : cam.status;
                    const stCol = camSt === 'online' ? '#00d26a' : (camSt === 'amber' ? '#ffc107' : '#f8312f');
                    const ipEsc = (cam.ip || '').replace(/'/g, "\\'");
                    return `<div class="dd-row" style="align-items:center;"><span class="dd-value" style="flex:1;"><a href="#" onclick="event.preventDefault(); document.getElementById('device-detail-modal').classList.remove('active'); document.getElementById('device-detail-modal').style.display='none'; openDeviceModal('${ipEsc}'); return false;" style="color:#4a9eff;">${String(cam.name || cam.ip || '‚Äî').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</a></span><span style="color:${stCol};font-size:12px;">‚óè ${(camSt || 'unknown').toUpperCase()}</span></div>`;
                }).join('');
                const exportBtn = nvrCameras.length > 0 ? `<button type="button" class="control-btn" style="margin-top:8px;" onclick="(function(){ var n=cachedDevices.find(function(x){ return (x.ip||'')==='${(d.ip||'').replace(/\\/g,'\\\\').replace(/'/g,"\\'")}'; }); if(n) exportNvrCamerasCsv(n.name, getCamerasOnNvr(n)); })();">Export CSV</button>` : '';
                return `<div class="dd-section">Cameras on this NVR</div>${nvrCameras.length ? `<div style="max-height:180px;overflow:auto;">${camRows}</div>${exportBtn}` : '<div style="color:#888;font-size:13px;">No cameras linked by name.</div>'}`;
            })() : '';
            let html = `
                <div class="dd-row"><span class="dd-label">Status</span><span class="dd-value" style="color:${stColor}">‚óè ${effectiveStatus.toUpperCase()}${statusSuffix}</span></div>
                <div class="dd-row"><span class="dd-label">Last online</span><span class="dd-value">${lastOnlineStr}</span></div>
                ${lastIssueStr ? `<div class="dd-row"><span class="dd-label">Last issue reported</span><span class="dd-value" style="color:#f8312f;">${lastIssueStr}</span></div>` : ''}
                <div class="dd-row"><span class="dd-label">Connect</span><span class="dd-value">${connectionUrl ? `<a href="${connectHref}" target="_blank" rel="noopener" style="color:#4a9eff;">Open in new tab</a>` : '‚Äî'}</span></div>
                ${nvrRow}
                ${locateRow}
                ${nvrCamerasSection}
                <div class="dd-section">Login page</div>
                ${isCloudMode ? `<div style="font-size:12px; color:#888; padding:6px 0;">${String(perDeviceLogin || '‚Äî').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div><div style="font-size:11px; color:#666;">Edits disabled in cloud view.</div>` : `<input type="text" id="dd-login-url" placeholder="e.g. https://host/ui/#/login or leave blank to use default" value="${(perDeviceLogin || '').replace(/"/g,'&quot;')}" style="width:100%; box-sizing:border-box; background:#222; color:#eee; border:1px solid #444; padding:8px; border-radius:6px; font-size:13px; font-family:monospace;"><button class="control-btn" style="margin-top:6px;" onclick="saveDeviceLoginUrl()">Save login page</button>`}
                <div class="dd-section">Details</div>
            `;

            const sysNameVal = displayDet.sysName ? String(displayDet.sysName).trim() : '';
            if(shouldShowLabel(uiType,'sysName')&&sysNameVal&&sysNameVal.toLowerCase()!=='unknown') html += `<div class="dd-row"><span class="dd-label">System Name</span><span class="dd-value">${displayDet.sysName}</span></div>`;

            // Show Switch + MAC first in Details (directly under NVR section). Only from linked switch in system.
            const isMacNetworkDevice = (uiType === 'cctv' || uiType === 'wap' || uiType === 'access_control');
            const macVal = det.mac || displayDet.mac;
            if (isMacNetworkDevice) {
                const linkedSwitchIp = det.linkedSwitchIp || det.switchIp || det.switch_ip || '';
                const swPort = det.switchPort || det.switch_port || '';
                const switchDevice = linkedSwitchIp ? cachedDevices.find(dev => (dev.ip || '').trim() === linkedSwitchIp.trim()) : null;
                if (switchDevice) {
                    const swIpDisplay = (switchDevice.ip || linkedSwitchIp || '').trim();
                    const swName = (switchDevice.name || switchDevice.ip || 'Switch').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
                    const swStatus = switchDevice.status || 'unknown';
                    const swStCol = swStatus === 'online' ? '#00d26a' : (swStatus === 'amber' ? '#ffc107' : '#f8312f');
                    const swConnectUrl = buildConnectionUrl(switchDevice, template, cachedDeviceLoginUrls[switchDevice.ip]);
                    const swConnectHref = swConnectUrl ? swConnectUrl.replace(/"/g,'&quot;') : '#';
                    const portText = swPort ? ` ‚Äî Port ${String(swPort).replace(/&/g,'&amp;')}` : '';
                    html += `<div class="dd-row"><span class="dd-label">Switch</span><span class="dd-value"><a href="${swConnectHref}" target="_blank" rel="noopener" style="color:#4a9eff;">${swName}</a> <span style="color:#888;font-family:monospace;font-size:12px;">${swIpDisplay}</span> <span style="color:${swStCol};font-size:12px;">‚óè ${swStatus.toUpperCase()}</span>${portText}</span></div>`;
                } else if (linkedSwitchIp) {
                    html += `<div class="dd-row"><span class="dd-label">Switch</span><span class="dd-value" style="color:#888;">${String(linkedSwitchIp).replace(/&/g,'&amp;')} <span style="color:#666;font-size:11px;">(not in system)</span></span></div>`;
                }
            }
            if(shouldShowLabel(uiType,'mac')&&macVal) html += `<div class="dd-row"><span class="dd-label">MAC Address</span><span class="dd-value">${macVal}</span></div>`;

            const showUptime = displayDet.uptime && (uiType !== 'firewall' || displayDet.uptime !== '0d');
            if(shouldShowLabel(uiType,'uptime')&&showUptime) html += `<div class="dd-row"><span class="dd-label">Uptime</span><span class="dd-value">${displayDet.uptime}</span></div>`;
            if(shouldShowLabel(uiType,'model')&&displayDet.model) html += `<div class="dd-row"><span class="dd-label">Model</span><span class="dd-value">${displayDet.model}</span></div>`;
            if(shouldShowLabel(uiType,'Model')&&displayDet.Model) html += `<div class="dd-row"><span class="dd-label">Model</span><span class="dd-value">${displayDet.Model}</span></div>`;
            if(shouldShowLabel(uiType,'serial')&&displayDet.serial) html += `<div class="dd-row"><span class="dd-label">Serial</span><span class="dd-value">${displayDet.serial}</span></div>`;
            if (isCamera && d.status === 'online' && (displayDet.cpu > 0 || displayDet.ram > 0 || displayDet.disk > 0)) {
                if(shouldShowLabel(uiType,'cpu')&&displayDet.cpu > 0) html += `<div class="dd-row"><span class="dd-label">CPU</span><span class="dd-value">${displayDet.cpu}%</span></div>`;
                if(shouldShowLabel(uiType,'ram')&&displayDet.ram > 0) html += `<div class="dd-row"><span class="dd-label">RAM</span><span class="dd-value">${displayDet.ram}%</span></div>`;
                if(shouldShowLabel(uiType,'disk')&&displayDet.disk > 0) html += `<div class="dd-row"><span class="dd-label">Disk</span><span class="dd-value">${displayDet.disk}%</span></div>`;
            }
            if (isCamera && (displayDet.HikvisionDiskSize || displayDet.HikvisionMemSize)) {
                if(shouldShowLabel(uiType,'HikvisionDiskSize')&&displayDet.HikvisionDiskSize) html += `<div class="dd-row"><span class="dd-label">Disk Size</span><span class="dd-value">${String(displayDet.HikvisionDiskSize).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span></div>`;
                if(shouldShowLabel(uiType,'HikvisionMemSize')&&displayDet.HikvisionMemSize) html += `<div class="dd-row"><span class="dd-label">Memory</span><span class="dd-value">${String(displayDet.HikvisionMemSize).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span></div>`;
            }
            if(shouldShowLabel(uiType,'HikvisionSysTime')&&isCamera && displayDet.HikvisionSysTime) html += `<div class="dd-row"><span class="dd-label">Device Time</span><span class="dd-value">${String(displayDet.HikvisionSysTime).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span></div>`;
            if(shouldShowLabel(uiType,'Traffic')&&isCamera && (displayDet.Total_Recv || displayDet.Total_Sent) && (displayDet.Total_Recv !== '0.00 GB' || displayDet.Total_Sent !== '0.00 GB')) {
                const recv = displayDet.Total_Recv || '‚Äî', sent = displayDet.Total_Sent || '‚Äî';
                html += `<div class="dd-row"><span class="dd-label">Traffic</span><span class="dd-value">‚Üì ${String(recv).replace(/&/g,'&amp;')} / ‚Üë ${String(sent).replace(/&/g,'&amp;')}</span></div>`;
            }

            const driveBar = shouldShowLabel(uiType,'driveBar') ? generateDriveBarHtml(det.note, uiType, det) : null;
            if (driveBar) {
                html += `<div class="dd-section">Storage & Status</div>`;
                html += driveBar;
            }
            if (uiType === 'printer' && (det.note || '').match(/[CMYK]:/)) {
                const rawNote = det.note || '';
                const tr = /([CMYK]):(\w+)%?/g;
                let m;
                const ts = {};
                while ((m = tr.exec(rawNote)) !== null) { ts[m[1]] = m[2] === 'OK' ? 100 : parseInt(m[2], 10); }
                if (Object.keys(ts).length > 0) {
                    html += `<div class="dd-section">Supplies</div><div class="stat-container" style="margin-top:6px;">`;
                    ['C','M','Y','K'].forEach(cl => {
                        if (ts[cl] !== undefined) {
                            const css = cl === 'C' ? 'fill-cyan' : (cl === 'M' ? 'fill-magenta' : (cl === 'Y' ? 'fill-yellow' : 'fill-black'));
                            const pct = Math.min(100, Math.max(0, ts[cl]));
                            const label = cl === 'C' ? 'Cyan' : (cl === 'M' ? 'Magenta' : (cl === 'Y' ? 'Yellow' : 'Black'));
                            html += `<div class="toner-row"><span class="toner-label" style="width:50px;">${label}</span><div class="stat-track" style="height:8px;"><div class="stat-fill ${css}" style="width:${pct}%"></div></div><span style="font-size:10px; color:#888; margin-left:6px;">${pct}%</span></div>`;
                        }
                    });
                    html += `</div>`;
                }
            }
            let noteForDisplay = displayDet.note ? String(displayDet.note) : '';
            if (isCamera && d.status === 'offline') noteForDisplay = 'Offline';
            if (isFirewall && noteForDisplay) noteForDisplay = noteForDisplay.replace(/\s*Up:\s*0d\s*\/?\s*/gi, '').replace(/\s*[Uu]ptime:\s*0d\s*/gi, '').replace(/\b0d\s*\/\s*uptime:\s*\d+d/g, '').replace(/\bUp:\s*\d+d\s*\/\s*uptime:\s*\d+d/gi, '').trim();
            const noteDisplay = noteForDisplay ? formatNoteForDisplay(noteForDisplay) : '';
            if(shouldShowLabel(uiType,'note')&&noteDisplay) html += `<div style="font-family:monospace; color:#ccc; font-size:13px; background:#111; padding:8px; border-radius:4px; margin-top:5px;">${noteDisplay}</div>`;
            if (!isCloudMode && (d.status === 'offline' || d.status === 'amber')) {
                html += `<div class="dd-section">Acknowledge fault</div><div style="display:flex; gap:8px; flex-wrap:wrap; align-items:center;"><select id="ack-duration" style="background:#333; color:#fff; border:1px solid #444; padding:6px 10px; border-radius:6px;"><option value="until_next_issue">Clear until next problem</option><option value="1h">1 hour</option><option value="1d">1 day</option><option value="until_online">Until device is online again</option><option value="forever">Forever</option></select><button class="control-btn" onclick="acknowledgeDeviceFromModal('${(d.ip||'').replace(/'/g, "\\'")}')">Acknowledge</button></div>`;
            }
            if (isCloudMode) {
                html += `<div class="dd-section">Notes</div><div style="font-size:12px; color:#888; padding:6px 0; white-space:pre-wrap;">${String(cachedDeviceNotes[d.ip] || '‚Äî').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</div><div style="font-size:11px; color:#666;">Edits disabled in cloud view.</div>`;
            } else {
                html += `<div class="dd-section">Notes</div><textarea id="dd-device-note" rows="3" placeholder="Add a note for this device..." style="width:100%; box-sizing:border-box; background:#222; color:#eee; border:1px solid #444; padding:8px; border-radius:6px; font-size:13px; resize:vertical;"></textarea><button class="control-btn" style="margin-top:6px;" onclick="saveDeviceNote()">Save note</button>`;
            }
            html += `<div class="dd-section">Debug Data</div>`;
            let debugDet = isCamera ? getCameraDisplayDetails(det) : { ...det };
            delete debugDet.Up;
            if (uiType === 'firewall' && debugDet.uptime === '0d') delete debugDet.uptime;
            if (isCamera) {
                delete debugDet.cpu; delete debugDet.disk; delete debugDet.ram;
                if (debugDet.uptime === '?') delete debugDet.uptime;
            }
            html += `<div style="max-height:150px; overflow:auto; background:#000; padding:10px; font-family:monospace; font-size:11px; color:#0f0; border:1px solid #333;">${JSON.stringify(debugDet, null, 2)}</div>`;

            cont.innerHTML = html;
            const noteEl = document.getElementById('dd-device-note');
            if (noteEl) noteEl.value = cachedDeviceNotes[d.ip] || '';
        }

        async function saveDeviceLoginUrl() {
            if (isCloudMode) return;
            if (!currentDeviceIpForNote) return;
            const el = document.getElementById('dd-login-url');
            const loginUrl = el ? el.value.trim() : '';
            const base = isCloudMode ? CLOUD_URL : '';
            try {
                const r = await fetch(base + '/api/device-login-urls', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ip: currentDeviceIpForNote, loginUrl: loginUrl }) });
                if (r.ok) {
                    const data = await r.json();
                    if (data.urls) cachedDeviceLoginUrls = data.urls;
                    if (loginUrl) cachedDeviceLoginUrls[currentDeviceIpForNote] = loginUrl;
                    else delete cachedDeviceLoginUrls[currentDeviceIpForNote];
                    if (el) el.placeholder = 'Saved.';
                    setTimeout(() => { const e = document.getElementById('dd-login-url'); if (e) e.placeholder = 'e.g. https://host/ui/#/login or leave blank to use default'; }, 2000);
                }
            } catch (e) { console.error(e); }
        }

        async function saveDeviceNote() {
            if (isCloudMode) return;
            if (!currentDeviceIpForNote) return;
            const noteEl = document.getElementById('dd-device-note');
            const note = noteEl ? noteEl.value : '';
            const base = isCloudMode ? CLOUD_URL : '';
            try {
                const r = await fetch(base + '/api/device-notes', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ip: currentDeviceIpForNote, note: note }) });
                if (r.ok) {
                    cachedDeviceNotes[currentDeviceIpForNote] = note;
                    if (noteEl) noteEl.placeholder = 'Saved.';
                    setTimeout(() => { if (noteEl) noteEl.placeholder = 'Add a note for this device...'; }, 2000);
                }
            } catch (e) { console.error(e); }
        }

        async function acknowledgeDeviceFromModal(ip) {
            const duration = (document.getElementById('ack-duration') && document.getElementById('ack-duration').value) || 'forever';
            await addAcknowledge(ip, duration);
            document.getElementById('device-detail-modal').classList.remove('active');
            document.getElementById('device-detail-modal').style.display = 'none';
            updateDashboard();
        }

        let pendingHistoryAckIps = [];
        function showHistoryAckDurationForIps(ips) {
            if (!ips || ips.length === 0) return;
            pendingHistoryAckIps = ips.map(ip => (ip || '').trim()).filter(Boolean);
            const bar = document.getElementById('history-ack-duration-bar');
            if (bar) bar.style.display = 'block';
        }
        function cancelHistoryAck() {
            pendingHistoryAckIps = [];
            const bar = document.getElementById('history-ack-duration-bar');
            if (bar) bar.style.display = 'none';
        }
        async function confirmHistoryAck(duration) {
            if (pendingHistoryAckIps.length === 0) return;
            await addAcknowledgeMultiple(pendingHistoryAckIps, duration);
            cancelHistoryAck();
            renderHistoryDetail();
            updateDashboard();
        }
        function updateHistoryAckSelectedBtn() {
            const wrap = document.getElementById('history-ack-selected-wrap');
            const checked = document.querySelectorAll('.history-ack-check:checked');
            const hasSelection = checked && checked.length > 0;
            if (wrap) wrap.style.display = hasSelection ? 'inline' : 'none';
        }
        function acknowledgeSelectedFromHistory() {
            const checked = document.querySelectorAll('.history-ack-check:checked');
            if (!checked || checked.length === 0) return;
            const ips = Array.from(checked).map(el => (el.getAttribute('data-ip') || '').trim()).filter(Boolean);
            if (ips.length === 0) return;
            showHistoryAckDurationForIps(ips);
        }

        async function addAcknowledge(ip, duration) {
            if (isCloudMode) return;
            const base = '';
            try {
                const r = await fetch(base + '/api/acknowledged-issues');
                let list = r.ok ? await r.json() : [];
                if (!Array.isArray(list)) list = [];
                const ipTrim = (ip || '').trim();
                const existing = list.findIndex(a => (a.ip || a.deviceIp || '').trim() === ipTrim);
                const entry = { ip: ipTrim, reason: 'Acknowledged from dashboard', expires: duration || 'forever', acknowledgedAt: new Date().toISOString() };
                if (existing >= 0) list[existing] = { ...list[existing], ...entry };
                else list.push(entry);
                await fetch(base + '/api/acknowledged-issues', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(list) });
                await loadAcknowledgedIssues();
            } catch (e) { console.error(e); }
        }
        async function addAcknowledgeMultiple(ips, duration) {
            if (isCloudMode || !ips || ips.length === 0) return;
            const base = '';
            try {
                const r = await fetch(base + '/api/acknowledged-issues');
                let list = r.ok ? await r.json() : [];
                if (!Array.isArray(list)) list = [];
                const entry = { reason: 'Acknowledged from dashboard', expires: duration || 'forever', acknowledgedAt: new Date().toISOString() };
                ips.forEach(ipTrim => {
                    const t = (ipTrim || '').trim();
                    if (!t) return;
                    const existing = list.findIndex(a => (a.ip || a.deviceIp || '').trim() === t);
                    const full = { ...entry, ip: t };
                    if (existing >= 0) list[existing] = { ...list[existing], ...full };
                    else list.push(full);
                });
                await fetch(base + '/api/acknowledged-issues', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(list) });
                await loadAcknowledgedIssues();
            } catch (e) { console.error(e); }
        }

        function setSort(c){ 
            if(currentSort.col===c) currentSort.dir*=-1; else{ currentSort.col=c; currentSort.dir=1; } 
            ['status','name','ip','details','updatedAt'].forEach(k=>document.getElementById(`sort-${k}`).innerText=''); 
            document.getElementById(`sort-${c}`).innerText=currentSort.dir===1?'‚ñ≤':'‚ñº'; 
            renderModalContent(); 
        }
        function toggleRaw(i){ document.getElementById('raw-'+i).classList.toggle('active'); }

        function getModalDeviceList(){
            if(!currentModalType) return [];
            let m = cachedDevices.filter(d=>getUiType(d)===currentModalType);
            const term = (document.getElementById('modal-search')&&document.getElementById('modal-search').value||'').toLowerCase();
            if(term) m = m.filter(d=>(d.name&&d.name.toLowerCase().includes(term))||(d.ip&&d.ip.includes(term)));
            m = m.slice().sort((a,b)=>{ let va=a[currentSort.col]||'', vb=b[currentSort.col]||''; if(currentSort.col==='details') va=JSON.stringify(a.details||{}); if(va<vb) return -1*currentSort.dir; if(va>vb) return 1*currentSort.dir; return 0; });
            return m;
        }

        function exportModalCSV(){
            const m = getModalDeviceList();
            if(!m.length){ alert('No devices in this list.'); return; }
            const base = isCloudMode ? CLOUD_URL : '';
            const headers = ['Name','IP','Type','Status','Note','Uptime','Last Seen'];
            const rows = m.map(d=>{
                const det = safeParseDetails(d.details);
                const note = (det&&det.note) ? String(det.note).replace(/"/g,'""') : '';
                const uptime = (det&&det.uptime) ? String(det.uptime) : '';
                return `"${(d.name||'').replace(/"/g,'""')}","${d.ip||''}","${d.type||''}","${d.status||''}","${note}","${uptime}","${d.updatedAt||d.last_seen||''}"`;
            });
            const csv = [headers.join(','), ...rows].join('\n');
            const blob = new Blob(['\uFEFF'+csv], { type: 'text/csv;charset=utf-8' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = (currentModalType||'devices') + '-export-' + Date.now() + '.csv';
            a.click();
            URL.revokeObjectURL(a.href);
        }

        async function refreshModalData(){
            const btn = document.getElementById('modal-refresh-btn');
            const base = isCloudMode ? CLOUD_URL : '';
            if (btn) { btn.disabled = true; btn.textContent = 'Refreshing‚Ä¶'; }
            try {
                const r = await fetch(base + '/api/devices');
                if(r.ok){ cachedDevices = await r.json(); renderModalContent(); }
            } catch(e){ console.error(e); }
            finally { if (btn) { btn.disabled = false; btn.textContent = 'üîÑ Refresh'; } }
        }

        function renderModalContent(){ 
            if(!currentModalType) return; 
            const tb=document.getElementById('modal-rows'); 
            tb.innerHTML=''; 
            const m = getModalDeviceList();
            const showRaw=document.getElementById('chk-show-raw')&&document.getElementById('chk-show-raw').checked; 
            
            m.forEach((d,i)=>{ 
                const tr=document.createElement('tr'); 
                let displayStatus = d.status;
                // If camera's linked NVR is offline, show camera as having an issue (can't record). Amber NVR = still recording.
                const isCameraRow = getUiType(d)==='cctv';
                if (isCameraRow) {
                    const linkedNvr = findNvrForCamera(d.name);
                    const linkedNvrSt = linkedNvr ? getEffectiveStatus(linkedNvr) : 'online';
                    if (linkedNvr && linkedNvrSt === 'offline' && displayStatus === 'online') displayStatus = 'amber';
                }
                let c=displayStatus==='online'?'#00d26a':(displayStatus==='amber'?'#ffc107':'#f8312f'); 
                const det=safeParseDetails(d.details);
                const isPrinterRow = getUiType(d)==='printer';
                const displayDet = isCameraRow ? getCameraDisplayDetails(det) : det;
                let dh=""; 
                if (isCameraRow && displayStatus === 'amber' && d.status === 'online') dh+=`<span style="color:#ffc107;">NVR offline ‚Äî not recording</span><br>`;
                const sysNameStr = displayDet.sysName ? String(displayDet.sysName).trim() : '';
                if(sysNameStr&&sysNameStr!==d.name&&sysNameStr.toLowerCase()!=='unknown') dh+=`<span style="color:#fff;">${displayDet.sysName}</span><br>`; 
                if(displayDet.note) dh+=`<span style="color:#aaa;">${formatNoteForDisplay(displayDet.note)}</span><br>`; 
                if(isPrinterRow&&(det.note||'').match(/[CMYK]:/)){
                    const rawNote = det.note || ''; const trg=/([CMYK]):(\w+)%?/g; let mm; const ts={};
                    while((mm=trg.exec(rawNote))!==null){ ts[mm[1]] = mm[2]==='OK' ? 100 : parseInt(mm[2],10); }
                    if(Object.keys(ts).length>0){
                        dh+=`<div class="stat-container" style="margin:6px 0;">`;
                        ['C','M','Y','K'].forEach(cl=>{
                            if(ts[cl]!==undefined){
                                const css=cl==='C'?'fill-cyan':(cl==='M'?'fill-magenta':(cl==='Y'?'fill-yellow':'fill-black'));
                                const pct=Math.min(100,Math.max(0,ts[cl]));
                                const label=cl==='C'?'Cyan':(cl==='M'?'Magenta':(cl==='Y'?'Yellow':'Black'));
                                dh+=`<div class="toner-row"><span class="toner-label" style="width:42px;">${label}</span><div class="stat-track" style="height:6px;"><div class="stat-fill ${css}" style="width:${pct}%"></div></div><span style="font-size:10px;color:#888;margin-left:4px;">${pct}%</span></div>`;
                            }
                        });
                        dh+=`</div>`;
                    }
                }
                dh+=`<span class="detail-sub">`; 
                Object.entries(displayDet).forEach(([k,v])=>{
                    if(k==='sysName'&&(!v||String(v).trim().toLowerCase()==='unknown')) return;
                    if(['cpu','ram','disk'].includes(k)&&(v==null||v===''||Number(v)===0)) return;
                    if(k!=='sysName'&&k!=='note'&&v!==null&&v!=='') dh+=`${k}: ${v}\n`;
                }); 
                dh+=`</span>`; 
                if(showRaw){ const cj=JSON.stringify({...d,_id:undefined},null,2); dh+=`<button class="raw-data-btn" onclick="toggleRaw(${i})">RAW</button><div id="raw-${i}" class="raw-view-box">${cj}</div>`; } 
                let ipDisplay = d.ip;
                const link = buildConnectionUrl(d, cachedMonitorSettings.deviceConnectionTemplate || 'http://{{ip}}', cachedDeviceLoginUrls[d.ip]) || ('http://' + (d.ip||'').trim());
                tr.innerHTML=`<td><div class="status-dot" style="background:${c};display:inline-block;vertical-align:middle;margin-right:8px;"></div><span style="font-weight:bold;color:${c}">${displayStatus}</span></td><td style="font-weight:600;font-size:15px;cursor:pointer;" onclick="openDeviceModal('${(d.ip||'').replace(/'/g,"\\'")}')">${d.name} üîç</td><td><a href="${link.replace(/"/g,'&quot;')}" target="_blank" style="color:#00d26a;text-decoration:none;font-family:monospace;border-bottom:1px dotted #00d26a;">${ipDisplay} ‚Üó</a></td><td>${dh||'‚Äî'}</td><td style="font-size:11px;color:#666;">${d.updatedAt?new Date(d.updatedAt).toLocaleTimeString():'--'}</td>`; 
                tb.appendChild(tr); 
            }); 
        }

        function buildGenericService(d, st, det, optTitle) {
            let p=[]; 
            const sn = (det.sysName||'').trim();
            if(sn&&sn!==d.name&&sn.toLowerCase()!=='unknown') p.push(det.sysName); 
            if(det.note) p.push(formatNoteForDisplay(det.note)); 
            if(det.uptime) p.push(det.uptime); 
            Object.keys(det).forEach(k=>{ 
                if(d.status === 'online' && getUiType(d) !== 'wap' && ['cpu','ram','disk','mem','hdd'].some(t=>k.toLowerCase().includes(t))) {
                    const v = det[k];
                    if(v!=null&&v!==''&&Number(v)!==0) p.push(`${k}: ${det[k]}`);
                }
            });
            const titleAttr = optTitle ? ' title="' + String(optTitle).replace(/"/g,'&quot;') + '"' : '';
            return `<div class="service-item" onclick="openDeviceModal('${d.ip}')"${titleAttr}><div style="display:flex;flex-direction:column;overflow:hidden;flex:1;min-width:0;"><span style="font-weight:600;">${d.name}</span>${p.length?`<div class="service-sub" style="color:#777;">${p.join(' ‚Ä¢ ')}</div>`:''}</div><div class="status-dot ${st}"></div></div>`;
        }

// --- CCTV NOTE FORMATTER ---
function formatCctvNote(note) {
    if (!note) return '';
    if (!note.includes('|')) return note; // Safety check

    return note.split('|').map(part => {
        const txt = part.trim();
        let cls = 'pill-idle'; // Default grey
        
        // Color Logic
        if (txt.includes('Streaming Active')) cls = 'pill-active';
        else if (txt.includes('Data Sent')) cls = 'pill-data';
        else if (txt.includes('FAIL') || txt.includes('Error')) cls = 'pill-active'; // Highlight errors
        
        return `<span class="cctv-pill ${cls}">${txt}</span>`;
    }).join('');
}

// POLL: every 5s. Single source: cachedDevices from /api/devices (agent updates DB via /api/update-status)
async function updateDashboard(){ 
    try{ 
        const base = isCloudMode ? CLOUD_URL : '';
        const u = base + '/api/devices';
        const startTime = performance.now();
        const r=await fetch(u); 
        const endTime = performance.now();
        const latencyMs = Math.round(endTime - startTime);
        const netPingEl = document.getElementById('net-ping');
        if (netPingEl) {
            netPingEl.innerText = latencyMs;
            netPingEl.style.color = latencyMs <= 50 ? '#00d26a' : (latencyMs <= 100 ? '#ffc107' : '#f8312f');
        } 
        cachedDevices=await r.json();
        await Promise.all([loadAcknowledgedIssues(), loadMonitorSettings(), loadDeviceNotes(), loadDeviceLoginUrls()]);
        const sig = cachedDevices.length + '|' + cachedDevices.map(d=> (d.ip||'') + ':' + (d.status||'') + ':' + (d.updatedAt||'') + ':' + ((d.floor_id||'')+'-'+JSON.stringify(d.map_coordinates||{})) + ':' + (d.details&&d.details.note ? String(d.details.note).slice(0,80) : '') + ':' + ((d.details&&d.details.linkedSwitchIp)||'')).join(';');
        if (sig === lastDevicesSig) return;
        lastDevicesSig = sig;
        pollCount++; if (pollCount % 3 === 0) loadHistoryPanel();
        const dev=cachedDevices.filter(d=>d.name&&d.name!=='undefined').sort((a,b)=>(a.name||'').localeCompare(b.name||'')); 
        if(currentModalType) renderModalContent(); 
        
        const ackIps = new Set(acknowledgedIssues.map(a => (a.ip || a.deviceIp || '').trim()).filter(Boolean));
        // Initialize HTML buckets
        let h={cloud:'',server:'',nvr:'',esxi:'',printer:'',cctv:'',switch:'',wap:'',tel:'',access:'',hw:'',firewall:''};
        let c={cloud:0,server:0,nvr:0,esxi:0,printer:0,cctv:0,switch:0,wap:0,tel:0,access:0,hw:0,firewall:0};
        
        dev.forEach(d=>{ 
            const t=getUiType(d); 
            const det=safeParseDetails(d.details); 
            let st=d.status==='online'?'online':(d.status==='amber'?'amber':'offline'); 
            
            // --- PRINTERS ---
            if(t==='printer'){ 
                let rawNote = det.note || ""; let errorMsg = ""; const tr=/([CMYK]):(\w+)%?/g; let m; const ts={}; 
                while((m=tr.exec(rawNote))!==null){ ts[m[1]] = m[2]==='OK' ? 100 : parseInt(m[2]); }
                let cleanNote = rawNote.replace(/([CMYK]):\w+%?/g, '').replace(/\|/g, '').trim();
                if(cleanNote.length > 2 && !cleanNote.includes("OK")) errorMsg = cleanNote;
                let isLow = Object.values(ts).some(v => v < 2); 
                let isJam = errorMsg.toLowerCase().match(/(jam|empty|no paper|error|offline)/);
                if (!ackIps.has((d.ip||'').trim())) { if (isJam) st = 'offline'; else if (isLow) st = 'amber'; else st = 'online'; }
                let tonerBars = "";
                if(Object.keys(ts).length>0){ 
                    tonerBars=`<div class="stat-container">`; 
                    ['C','M','Y','K'].forEach(cl=>{ 
                        if(ts[cl]!==undefined){ 
                            let css=cl==='C'?'fill-cyan':(cl==='M'?'fill-magenta':(cl==='Y'?'fill-yellow':'fill-black')); 
                            tonerBars+=`<div class="toner-row"><span class="toner-label">${cl}</span><div class="stat-track" style="height:4px;"><div class="stat-fill ${css}" style="width:${ts[cl]}%"></div></div></div>`; 
                        } 
                    }); 
                    tonerBars+=`</div>`; 
                }
                let statusHtml = errorMsg ? `<div style="font-size:11px; color:#ffffff; margin-top:2px;">‚ö†Ô∏è ${errorMsg}</div>` : "";
                const supplyTitle = Object.keys(ts).length > 0 ? ['C','M','Y','K'].filter(c=>ts[c]!==undefined).map(c=>c+':'+(ts[c]===100?'OK':ts[c]+'%')).join(' ') : 'Toner N/A';
                const printerTitle = supplyTitle + (errorMsg ? ' | ‚ö†Ô∏è ' + errorMsg.replace(/"/g,'&quot;') : '');
                h.printer += `<div class="service-item" onclick="openDeviceModal('${d.ip}')" title="${printerTitle.replace(/"/g,'&quot;')}" style="flex-direction:column;align-items:stretch;padding:10px 0;"><div style="display:flex;justify-content:space-between;align-items:center;"><div style="display:flex;flex-direction:column;"><span style="font-weight:600;">${d.name}</span>${statusHtml}</div><div class="status-dot ${st}"></div></div>${tonerBars}</div>`; c.printer++; 
            }
            // --- FIREWALL (CPU/RAM like servers, under latency) ---
            else if(t==='firewall'){ 
                const fwUptime = (det.uptime && det.uptime !== '0d') ? det.uptime : null;
                let cpu = parseInt(det.cpu || det.CPU || 0, 10), ram = parseInt(det.ram || det.RAM || 0, 10);
                let fwStats = '';
                if (d.status === 'online' && (cpu > 0 || ram > 0)) {
                    fwStats = `<div class="stat-container">${cpu > 0 ? `<div class="stat-row"><span class="stat-label">CPU</span><div class="stat-track"><div class="stat-fill fill-cpu" style="width:${cpu}%"></div></div></div>` : ''}${ram > 0 ? `<div class="stat-row"><span class="stat-label">RAM</span><div class="stat-track"><div class="stat-fill fill-ram" style="width:${ram}%"></div></div></div>` : ''}</div>`;
                }
                const fwName = (det.sysName&&String(det.sysName).trim().toLowerCase()!=='unknown') ? det.sysName : d.name;
                h.firewall+=`<div onclick="openDeviceModal('${d.ip}')" style="cursor:pointer; margin-bottom:15px;border-bottom:1px solid #444;padding-bottom:10px;"><div class="fw-row"><span class="fw-label">Device</span><span class="fw-val">${fwName}</span></div><div class="fw-row"><span class="fw-label">Status</span><div class="status-dot ${st}"></div></div>${fwUptime ? `<div class="fw-row"><span class="fw-label">Uptime</span><span class="fw-val" style="color:#00d26a;">${fwUptime}</span></div>` : ''}${fwStats}</div>`; c.firewall++; 
            }
            // --- SWITCHES ---
            else if(t==='switch'){ 
                const note = det.note || ''; const sn = (det.sysName||'').trim(); const switchInfo = note || (sn && sn.toLowerCase()!=='unknown' ? det.sysName : '') || 'Online';
                h.switch+=`<div class="service-item" onclick="openDeviceModal('${d.ip}')" style="flex-direction:column;align-items:stretch;padding:10px 0;"><div style="display:flex;justify-content:space-between;align-items:center;"><span style="font-weight:600;">${d.name}</span><div class="status-dot ${st}"></div></div><div class="service-sub" style="margin-top:5px;color:#888;">${switchInfo}</div></div>`; c.switch++; 
            }
            // --- NVR & HARDWARE (Disk Checks) - one block per drive; missing drives as red blocks ---
            else if(t==='nvr' || t==='hardware'){ 
                const note = det.note || '';
                const hasDriveInfo = note.includes('Cap:') || note.includes('Drives') || note.includes('RAID') || note.includes('Disk ') || note.includes('All drives OK');
                let totalDrives = 0;
                if (det.diskCount != null && det.diskCount !== '') totalDrives = parseInt(det.diskCount, 10) || 0;
                if (totalDrives <= 0) {
                    const drivesMatch = note.match(/(\d+)\s*Drives?/i) || note.match(/Cap:\s*[\d.]+\s*TB\s*\|\s*(\d+)/i);
                    if (drivesMatch) totalDrives = parseInt(drivesMatch[1], 10) || 0;
                }
                const diskMatches = note.match(/Disk\s*(\d+)/gi) || [];
                const diskNumbers = diskMatches.map(m => { const n = m.match(/\d+/); return n ? parseInt(n[0], 10) : 0; }).filter(n => n > 0);
                const maxDiskNum = diskNumbers.length > 0 ? Math.max(...diskNumbers) : 0;
                if (totalDrives <= 0 && maxDiskNum > 0) totalDrives = maxDiskNum;
                totalDrives = Math.max(totalDrives, maxDiskNum, 1);
                if (totalDrives <= 0 && (note.includes('RAID OK') || note.includes('All drives OK'))) totalDrives = 4;
                let expectedDrives = totalDrives;
                const expectedMatch = note.match(/expected\s+(\d+)/i);
                if (expectedMatch) expectedDrives = Math.max(parseInt(expectedMatch[1], 10) || totalDrives, totalDrives);
                const statusByDrive = parseDriveStatusByNumber(note, totalDrives);
                let driveBar = '';
                if (hasDriveInfo && expectedDrives > 0) {
                    const segmentWidth = 100 / expectedDrives; let barSegments = '';
                    for (let i = 1; i <= expectedDrives; i++) {
                        const stDr = i <= totalDrives ? (statusByDrive[i] || 'ok') : 'error';
                        const color = stDr === 'error' ? '#f8312f' : (stDr === 'warning' ? '#ffc107' : '#00d26a');
                        barSegments += `<div class="drive-block" style="width:${segmentWidth}%;background:${color};"></div>`;
                    }
                    driveBar = `<div class="stat-container"><div class="stat-row"><span class="stat-label">DISK</span><div class="stat-track" style="display:flex;overflow:hidden;background:#222;">${barSegments}</div></div></div>`;
                }
                const hasError = /Disk\s*\d+\s*(FAIL|Offline|Abnormal|SmartFailed)/i.test(note);
                const hasWarning = Object.values(statusByDrive).some(v => v === 'warning') || /drive\(s\)\s*missing|missing\s*drive/i.test(note);
                if (!ackIps.has((d.ip||'').trim())) { if (hasError) st = 'offline'; else if (hasWarning) st = 'amber'; }
                const capMatch = note.match(/Cap:\s*([\d.]+)\s*TB/i); const capacity = capMatch ? capMatch[1] + 'TB' : '';
                let statusMsg = note.replace(/Cap:\s*[\d.]+\s*TB\s*\|\s*/i, '').replace(/\d+\s*Drives?\s*\|\s*/gi, '').trim();
                let subInfo = capacity ? `${capacity}` : ''; if (statusMsg && statusMsg !== subInfo) subInfo = subInfo ? `${subInfo} ‚Ä¢ ${statusMsg}` : statusMsg;
                
                let ih=`<div class="service-item" onclick="openDeviceModal('${d.ip}')" style="flex-direction:column;align-items:stretch;padding:10px 0;"><div style="display:flex;justify-content:space-between;align-items:center;"><span style="font-weight:600;">${d.name}</span><div class="status-dot ${st}"></div></div>${driveBar}${subInfo ? `<div class="service-sub" style="margin-top:5px;color:#888;">${subInfo}</div>` : ''}</div>`; 
                if(t==='nvr'){ h.nvr+=ih; c.nvr++; } else{ h.hw+=ih; c.hw++; }
            }
            // --- SERVERS ---
            else if(t==='server' || t==='esxi'){ 
                let cpu=parseInt(det.cpu||det.CPU||0), ram=parseInt(det.ram||det.RAM||0), disk=parseInt(det.disk||det.DISK||0); let sh=''; 
                if(d.status === 'online' && (cpu>0||ram>0)){ sh=`<div class="stat-container"><div class="stat-row"><span class="stat-label">CPU</span><div class="stat-track"><div class="stat-fill fill-cpu" style="width:${cpu}%"></div></div></div>${ram>0?`<div class="stat-row"><span class="stat-label">RAM</span><div class="stat-track"><div class="stat-fill fill-ram" style="width:${ram}%"></div></div></div>`:''}${disk>0?`<div class="stat-row"><span class="stat-label">HDD</span><div class="stat-track"><div class="stat-fill fill-disk" style="width:${disk}%"></div></div></div>`:''}</div>`; } else if (det.note) { sh=`<div class="service-sub" style="margin-top:5px;color:#888;">${formatNoteForDisplay(det.note)}</div>`; }
                let ih=`<div class="service-item" onclick="openDeviceModal('${d.ip}')" style="flex-direction:column;align-items:stretch;padding:10px 0;"><div style="display:flex;justify-content:space-between;align-items:center;"><span style="font-weight:600;">${d.name}</span><div class="status-dot ${st}"></div></div>${sh}</div>`; 
                if(t==='esxi'){ h.esxi+=ih; c.esxi++; } else{ h.server+=ih; c.server++; } 
            }
            
// --- ENHANCED CCTV BLOCK ---
            else if(t === 'cctv') {
                let pills = '';
                let cameraNote = (d.status === 'offline')
                    ? 'Offline'
                    : (det.note || '').replace(/\|\s*Uptime:\s*\?/gi, '').replace(/\|\s*$/g, '').trim();
                if (d.status === 'online' && d.upSince) {
                    const u = (det.uptime || '').trim();
                    if (u === '?' || u === '1m' || u === '<1m') {
                        const seenFor = formatSeenFor(d.upSince);
                        cameraNote = (det.note || '').replace(/\|\s*Uptime:\s*(?:\?|1m|<1m)\s*/gi, '| ' + seenFor + ' ').replace(/\|\s*$/g, '').trim();
                    }
                }

                if (det.resolution || det.fps || det.bitrate) {
                    if (det.resolution) pills += `<span class="cctv-pill pill-idle">${det.resolution}</span>`;
                    if (det.fps)        pills += `<span class="cctv-pill pill-active">${det.fps} fps</span>`;
                    if (det.bitrate)    pills += `<span class="cctv-pill pill-data">${det.bitrate}</span>`;
                }
                else if (cameraNote && cameraNote.includes('|')) {
                    pills = formatCctvNote(cameraNote);
                }
                else if (cameraNote) {
                    pills = `<span style="color:#888; font-size: 0.8em;">${cameraNote}</span>`;
                }
                else {
                    pills = `<span style="color:#444; font-style: italic; font-size: 0.8em;">No Info</span>`;
                }

                // If this camera's linked NVR is offline, show camera as having an issue (can't record). Amber NVR = still recording.
                const linkedNvr = findNvrForCamera(d.name);
                const linkedNvrSt = linkedNvr ? getEffectiveStatus(linkedNvr) : 'online';
                if (linkedNvr && linkedNvrSt === 'offline' && st === 'online') st = 'amber';

                const hikCpu = parseInt(det.cpu, 10) || 0, hikRam = parseInt(det.ram, 10) || 0, hikDisk = parseInt(det.disk, 10) || 0;
                const hikStats = (d.status === 'online') ? [hikCpu > 0 ? 'CPU ' + hikCpu + '%' : '', hikRam > 0 ? 'RAM ' + hikRam + '%' : '', hikDisk > 0 ? 'Disk ' + hikDisk + '%' : ''].filter(Boolean).join(' ¬∑ ') : '';
                const hikStatsLine = hikStats ? `<div class="service-sub" style="margin-top:4px;color:#888;font-size:11px;">${hikStats}</div>` : '';

                h.cctv += `<div class="service-item" onclick="openDeviceModal('${d.ip}')" style="flex-direction:column;align-items:stretch;padding:10px 0;">
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <span style="font-weight:600;">${d.name}</span>
                        <div class="status-dot ${st}"></div>
                    </div>
                    <div style="margin-top:5px;">${pills}</div>
                    ${hikStatsLine}
                </div>`;
                c.cctv++;
            }

            else{ 
                let wapTitle = '';
                if(t==='wap'||t==='wifi'||t==='ap') {
                    const clientsMatch = (det.note||'').match(/Clients?:\s*(\d+)/i);
                    wapTitle = (d.ip||'') + (clientsMatch ? ' ‚Ä¢ ' + clientsMatch[1] + ' clients' : '');
                }
                const it=buildGenericService(d,st,det,wapTitle||undefined); 
                if(t==='wap'){ h.wap+=it; c.wap++; } else if(t==='telephone'){ h.tel+=it; c.tel++; } else if(t==='access_control'){ h.access+=it; c.access++; } else if(t==='service'){ h.cloud+=it; c.cloud++; } else{ h.hw+=it; c.hw++; } 
            } 
        });

        const mi={'cloud':'cloud-window','server':'server-window','nvr':'nvr-list','esxi':'esxi-list','printer':'printer-window','cctv':'cctv-list','switch':'switch-window','wap':'wap-list','tel':'tel-list','access':'access-list','hw':'hardware-list'}; 
        Object.keys(mi).forEach(k=>{ const el=document.getElementById(mi[k]); if(el) el.innerHTML = h[k] || '<div class="service-item" style="color:#555;">No devices</div>'; const ce=document.getElementById(`c-${k}`); if(ce) ce.innerText=`(${c[k]})`; }); 
        document.getElementById('firewall-content').innerHTML = h.firewall || '<div style="text-align:center;color:#666;">No Firewall Found</div>';
        plotDevicesOnMap();
        // Refresh device detail popup if open so camera/NVR status updates when NVR comes back online
        const ddModal = document.getElementById('device-detail-modal');
        if (currentDeviceIpForNote && ddModal && ddModal.style.display !== 'none') {
            openDeviceModal(currentDeviceIpForNote);
        }
    }catch(e){ console.error(e); } 
}

        // === INITIALIZATION ===
        window.addEventListener('DOMContentLoaded',()=>{ 
            try {
                const chk = document.getElementById('map-labels-toggle');
                if (chk) { const saved = localStorage.getItem('mapLabelsVisible'); if (saved !== null) { chk.checked = (saved === 'true'); mapLabelsVisible = chk.checked; } }
                const cctvChk = document.getElementById('map-cctv-coverage-toggle');
                if (cctvChk) { const saved = localStorage.getItem('mapCctvCoverageVisible'); const legacy = localStorage.getItem('mapConesVisible'); const on = saved !== null ? (saved === 'true') : (legacy === 'true'); cctvChk.checked = on; mapCctvCoverageVisible = on; if (saved === null && legacy !== null) try { localStorage.setItem('mapCctvCoverageVisible', on ? 'true' : 'false'); } catch(e){} }
                const wapChk = document.getElementById('map-wap-coverage-toggle');
                if (wapChk) { const saved = localStorage.getItem('mapWapCoverageVisible'); const legacy = localStorage.getItem('mapConesVisible'); const on = saved !== null ? (saved === 'true') : (legacy === 'true'); wapChk.checked = on; mapWapCoverageVisible = on; if (saved === null && legacy !== null) try { localStorage.setItem('mapWapCoverageVisible', on ? 'true' : 'false'); } catch(e){} }
            } catch(e) {}
            Object.entries({'nvr':'nvr-list','cctv':'cctv-list','printer':'printer-window','switch':'switch-window','wap':'wap-list','telephone':'tel-list','access_control':'access-list','hardware':'hardware-list','server':'server-window','service':'cloud-window','esxi':'esxi-list'}).forEach(([t,id])=>{ 
                const el=document.getElementById(id); if(!el) return; if(hiddenTypes.has(t)){ el.classList.add('minimized'); el.previousElementSibling.querySelector('.toggle-btn')?.classList.add('hidden-active'); } if(expandedTypes.has(t)){ el.classList.add('expanded'); el.previousElementSibling.querySelector('.expand-btn')?.classList.add('expanded-active'); } 
            }); 
            startInternalScroll(); loadMapConfig(); loadGlobalConfig(); updateDashboard(); setInterval(updateDashboard,5000); 
            try { const bc = new BroadcastChannel('school-monitor'); bc.onmessage = (e) => { if (e.data && e.data.type === 'devices-updated') updateDashboard(); }; } catch (e) {}
            setInterval(function() {
                var dd = document.getElementById('device-detail-modal');
                var mo = document.getElementById('modal-overlay');
                var hm = document.getElementById('history-modal');
                var cm = document.getElementById('clock-theme-modal');
                var modalOpen = (dd && dd.classList.contains('active')) || (mo && mo.classList.contains('active')) || (hm && hm.classList.contains('active') && hm.style.display !== 'none') || (cm && cm.classList.contains('active'));
                if (!modalOpen) location.reload();
            }, 10 * 60 * 1000);
        });
        window.addEventListener('load', function(){
            try { map.invalidateSize(); plotDevicesOnMap(); } catch(e){}
        });
    </script>
</body>
</html>
